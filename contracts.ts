export const ErrorSelectors = {
  LSP0ERC725Account: {
    /**
     * error CannotTransferOwnershipToSelf()
     *
     * 0x43b248cd = keccak256('CannotTransferOwnershipToSelf()')
     */
    "0x43b248cd": {
      sig: "CannotTransferOwnershipToSelf()",
      inputs: [],
      name: "CannotTransferOwnershipToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to transfer ownership to the address(this)",
        },
      ],
    },

    /**
     * error ERC725X_ContractDeploymentFailed()
     *
     * 0x0b07489b = keccak256('ERC725X_ContractDeploymentFailed()')
     */
    "0x0b07489b": {
      sig: "ERC725X_ContractDeploymentFailed()",
      inputs: [],
      name: "ERC725X_ContractDeploymentFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when contract deployment via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` failed. whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_CreateOperationsRequireEmptyRecipientAddress()
     *
     * 0x3041824a = keccak256('ERC725X_CreateOperationsRequireEmptyRecipientAddress()')
     */
    "0x3041824a": {
      sig: "ERC725X_CreateOperationsRequireEmptyRecipientAddress()",
      inputs: [],
      name: "ERC725X_CreateOperationsRequireEmptyRecipientAddress",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when passing a `to` address while deploying a contract va `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersEmptyArray()
     *
     * 0xe9ad2b5f = keccak256('ERC725X_ExecuteParametersEmptyArray()')
     */
    "0xe9ad2b5f": {
      sig: "ERC725X_ExecuteParametersEmptyArray()",
      inputs: [],
      name: "ERC725X_ExecuteParametersEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `executeBatch(uint256[],address[],uint256[],bytes[]) is an empty array",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersLengthMismatch()
     *
     * 0x3ff55f4d = keccak256('ERC725X_ExecuteParametersLengthMismatch()')
     */
    "0x3ff55f4d": {
      sig: "ERC725X_ExecuteParametersLengthMismatch()",
      inputs: [],
      name: "ERC725X_ExecuteParametersLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of operation, to addresses, value, and data.",
        },
      ],
    },

    /**
     * error ERC725X_InsufficientBalance(
     *  uint256 balance,
     *  uint256 value
     * )
     *
     * 0x0df9a8f8 = keccak256('ERC725X_InsufficientBalance(uint256,uint256)')
     */
    "0x0df9a8f8": {
      sig: "ERC725X_InsufficientBalance(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "ERC725X_InsufficientBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to send more native tokens `value` than available in current `balance`.",
          params: {
            balance: "the balance of the ERC725X contract.",
            value:
              "the amount of native tokens sent via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`.",
          },
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInDelegateCall()
     *
     * 0x5ac83135 = keccak256('ERC725X_MsgValueDisallowedInDelegateCall()')
     */
    "0x5ac83135": {
      sig: "ERC725X_MsgValueDisallowedInDelegateCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInDelegateCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a delegatecall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because msg.value is persisting.",
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInStaticCall()
     *
     * 0x72f2bc6a = keccak256('ERC725X_MsgValueDisallowedInStaticCall()')
     */
    "0x72f2bc6a": {
      sig: "ERC725X_MsgValueDisallowedInStaticCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInStaticCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a staticcall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because sending native tokens is a state changing operation.",
        },
      ],
    },

    /**
     * error ERC725X_NoContractBytecodeProvided()
     *
     * 0xb81cd8d9 = keccak256('ERC725X_NoContractBytecodeProvided()')
     */
    "0xb81cd8d9": {
      sig: "ERC725X_NoContractBytecodeProvided()",
      inputs: [],
      name: "ERC725X_NoContractBytecodeProvided",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when no contract bytecode was provided as parameter when trying to deploy a contract via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`, whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_UnknownOperationType(
     *  uint256 operationTypeProvided
     * )
     *
     * 0x7583b3bc = keccak256('ERC725X_UnknownOperationType(uint256)')
     */
    "0x7583b3bc": {
      sig: "ERC725X_UnknownOperationType(uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "operationTypeProvided",
          type: "uint256",
        },
      ],
      name: "ERC725X_UnknownOperationType",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `operationTypeProvided` is none of the default operation types available. (CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4)",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error LSP20CallingVerifierFailed(
     *  bool postCall
     * )
     *
     * 0x8c6a8ae3 = keccak256('LSP20CallingVerifierFailed(bool)')
     */
    "0x8c6a8ae3": {
      sig: "LSP20CallingVerifierFailed(bool)",
      inputs: [{ internalType: "bool", name: "postCall", type: "bool" }],
      name: "LSP20CallingVerifierFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the call to the owner fail with no revert reason",
          params: {
            postCall: "True if the execution call was done, False otherwise",
          },
        },
      ],
    },

    /**
     * error LSP20InvalidMagicValue(
     *  bool postCall,
     *  bytes returnedData
     * )
     *
     * 0xd088ec40 = keccak256('LSP20InvalidMagicValue(bool,bytes)')
     */
    "0xd088ec40": {
      sig: "LSP20InvalidMagicValue(bool,bytes)",
      inputs: [
        { internalType: "bool", name: "postCall", type: "bool" },
        { internalType: "bytes", name: "returnedData", type: "bytes" },
      ],
      name: "LSP20InvalidMagicValue",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the call to the owner does not return the magic value",
          params: {
            postCall: "The data returned by the call to the logic verifier",
          },
        },
      ],
    },

    /**
     * error NoExtensionFoundForFunctionSelector(
     *  bytes4 functionSelector
     * )
     *
     * 0xbb370b2b = keccak256('NoExtensionFoundForFunctionSelector(bytes4)')
     */
    "0xbb370b2b": {
      sig: "NoExtensionFoundForFunctionSelector(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "functionSelector", type: "bytes4" },
      ],
      name: "NoExtensionFoundForFunctionSelector",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is no extension for the function selector being called with",
        },
      ],
    },

    /**
     * error NotInRenounceOwnershipInterval(
     *  uint256 renounceOwnershipStart,
     *  uint256 renounceOwnershipEnd
     * )
     *
     * 0x8b9bf507 = keccak256('NotInRenounceOwnershipInterval(uint256,uint256)')
     */
    "0x8b9bf507": {
      sig: "NotInRenounceOwnershipInterval(uint256,uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "renounceOwnershipStart",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "renounceOwnershipEnd",
          type: "uint256",
        },
      ],
      name: "NotInRenounceOwnershipInterval",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to renounce ownership before the initial confirmation delay",
        },
      ],
    },
  },
  LSP0ERC725AccountInit: {
    /**
     * error CannotTransferOwnershipToSelf()
     *
     * 0x43b248cd = keccak256('CannotTransferOwnershipToSelf()')
     */
    "0x43b248cd": {
      sig: "CannotTransferOwnershipToSelf()",
      inputs: [],
      name: "CannotTransferOwnershipToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to transfer ownership to the address(this)",
        },
      ],
    },

    /**
     * error ERC725X_ContractDeploymentFailed()
     *
     * 0x0b07489b = keccak256('ERC725X_ContractDeploymentFailed()')
     */
    "0x0b07489b": {
      sig: "ERC725X_ContractDeploymentFailed()",
      inputs: [],
      name: "ERC725X_ContractDeploymentFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when contract deployment via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` failed. whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_CreateOperationsRequireEmptyRecipientAddress()
     *
     * 0x3041824a = keccak256('ERC725X_CreateOperationsRequireEmptyRecipientAddress()')
     */
    "0x3041824a": {
      sig: "ERC725X_CreateOperationsRequireEmptyRecipientAddress()",
      inputs: [],
      name: "ERC725X_CreateOperationsRequireEmptyRecipientAddress",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when passing a `to` address while deploying a contract va `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersEmptyArray()
     *
     * 0xe9ad2b5f = keccak256('ERC725X_ExecuteParametersEmptyArray()')
     */
    "0xe9ad2b5f": {
      sig: "ERC725X_ExecuteParametersEmptyArray()",
      inputs: [],
      name: "ERC725X_ExecuteParametersEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `executeBatch(uint256[],address[],uint256[],bytes[]) is an empty array",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersLengthMismatch()
     *
     * 0x3ff55f4d = keccak256('ERC725X_ExecuteParametersLengthMismatch()')
     */
    "0x3ff55f4d": {
      sig: "ERC725X_ExecuteParametersLengthMismatch()",
      inputs: [],
      name: "ERC725X_ExecuteParametersLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of operation, to addresses, value, and data.",
        },
      ],
    },

    /**
     * error ERC725X_InsufficientBalance(
     *  uint256 balance,
     *  uint256 value
     * )
     *
     * 0x0df9a8f8 = keccak256('ERC725X_InsufficientBalance(uint256,uint256)')
     */
    "0x0df9a8f8": {
      sig: "ERC725X_InsufficientBalance(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "ERC725X_InsufficientBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to send more native tokens `value` than available in current `balance`.",
          params: {
            balance: "the balance of the ERC725X contract.",
            value:
              "the amount of native tokens sent via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`.",
          },
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInDelegateCall()
     *
     * 0x5ac83135 = keccak256('ERC725X_MsgValueDisallowedInDelegateCall()')
     */
    "0x5ac83135": {
      sig: "ERC725X_MsgValueDisallowedInDelegateCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInDelegateCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a delegatecall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because msg.value is persisting.",
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInStaticCall()
     *
     * 0x72f2bc6a = keccak256('ERC725X_MsgValueDisallowedInStaticCall()')
     */
    "0x72f2bc6a": {
      sig: "ERC725X_MsgValueDisallowedInStaticCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInStaticCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a staticcall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because sending native tokens is a state changing operation.",
        },
      ],
    },

    /**
     * error ERC725X_NoContractBytecodeProvided()
     *
     * 0xb81cd8d9 = keccak256('ERC725X_NoContractBytecodeProvided()')
     */
    "0xb81cd8d9": {
      sig: "ERC725X_NoContractBytecodeProvided()",
      inputs: [],
      name: "ERC725X_NoContractBytecodeProvided",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when no contract bytecode was provided as parameter when trying to deploy a contract via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`, whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_UnknownOperationType(
     *  uint256 operationTypeProvided
     * )
     *
     * 0x7583b3bc = keccak256('ERC725X_UnknownOperationType(uint256)')
     */
    "0x7583b3bc": {
      sig: "ERC725X_UnknownOperationType(uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "operationTypeProvided",
          type: "uint256",
        },
      ],
      name: "ERC725X_UnknownOperationType",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `operationTypeProvided` is none of the default operation types available. (CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4)",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error LSP20CallingVerifierFailed(
     *  bool postCall
     * )
     *
     * 0x8c6a8ae3 = keccak256('LSP20CallingVerifierFailed(bool)')
     */
    "0x8c6a8ae3": {
      sig: "LSP20CallingVerifierFailed(bool)",
      inputs: [{ internalType: "bool", name: "postCall", type: "bool" }],
      name: "LSP20CallingVerifierFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the call to the owner fail with no revert reason",
          params: {
            postCall: "True if the execution call was done, False otherwise",
          },
        },
      ],
    },

    /**
     * error LSP20InvalidMagicValue(
     *  bool postCall,
     *  bytes returnedData
     * )
     *
     * 0xd088ec40 = keccak256('LSP20InvalidMagicValue(bool,bytes)')
     */
    "0xd088ec40": {
      sig: "LSP20InvalidMagicValue(bool,bytes)",
      inputs: [
        { internalType: "bool", name: "postCall", type: "bool" },
        { internalType: "bytes", name: "returnedData", type: "bytes" },
      ],
      name: "LSP20InvalidMagicValue",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the call to the owner does not return the magic value",
          params: {
            postCall: "The data returned by the call to the logic verifier",
          },
        },
      ],
    },

    /**
     * error NoExtensionFoundForFunctionSelector(
     *  bytes4 functionSelector
     * )
     *
     * 0xbb370b2b = keccak256('NoExtensionFoundForFunctionSelector(bytes4)')
     */
    "0xbb370b2b": {
      sig: "NoExtensionFoundForFunctionSelector(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "functionSelector", type: "bytes4" },
      ],
      name: "NoExtensionFoundForFunctionSelector",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is no extension for the function selector being called with",
        },
      ],
    },

    /**
     * error NotInRenounceOwnershipInterval(
     *  uint256 renounceOwnershipStart,
     *  uint256 renounceOwnershipEnd
     * )
     *
     * 0x8b9bf507 = keccak256('NotInRenounceOwnershipInterval(uint256,uint256)')
     */
    "0x8b9bf507": {
      sig: "NotInRenounceOwnershipInterval(uint256,uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "renounceOwnershipStart",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "renounceOwnershipEnd",
          type: "uint256",
        },
      ],
      name: "NotInRenounceOwnershipInterval",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to renounce ownership before the initial confirmation delay",
        },
      ],
    },
  },
  LSP11BasicSocialRecovery: {
    /**
     * error AddressZeroNotAllowed()
     *
     * 0x0855380c = keccak256('AddressZeroNotAllowed()')
     */
    "0x0855380c": {
      sig: "AddressZeroNotAllowed()",
      inputs: [],
      name: "AddressZeroNotAllowed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the address zero calls `recoverOwnership(..)` function",
        },
      ],
    },

    /**
     * error CallerIsNotGuardian(
     *  address caller
     * )
     *
     * 0x5560e16d = keccak256('CallerIsNotGuardian(address)')
     */
    "0x5560e16d": {
      sig: "CallerIsNotGuardian(address)",
      inputs: [{ internalType: "address", name: "caller", type: "address" }],
      name: "CallerIsNotGuardian",
      type: "error",
      userdoc: [{ details: "reverts when the caller is not a guardian" }],
    },

    /**
     * error GuardianAlreadyExist(
     *  address addressToAdd
     * )
     *
     * 0xd52858db = keccak256('GuardianAlreadyExist(address)')
     */
    "0xd52858db": {
      sig: "GuardianAlreadyExist(address)",
      inputs: [
        { internalType: "address", name: "addressToAdd", type: "address" },
      ],
      name: "GuardianAlreadyExist",
      type: "error",
      userdoc: [
        { details: "reverts when adding an already existing guardian" },
      ],
    },

    /**
     * error GuardianDoNotExist(
     *  address addressToRemove
     * )
     *
     * 0x3d8e524e = keccak256('GuardianDoNotExist(address)')
     */
    "0x3d8e524e": {
      sig: "GuardianDoNotExist(address)",
      inputs: [
        { internalType: "address", name: "addressToRemove", type: "address" },
      ],
      name: "GuardianDoNotExist",
      type: "error",
      userdoc: [{ details: "reverts when removing a non-existing guardian" }],
    },

    /**
     * error GuardiansNumberCannotGoBelowThreshold(
     *  uint256 guardianThreshold
     * )
     *
     * 0x27113777 = keccak256('GuardiansNumberCannotGoBelowThreshold(uint256)')
     */
    "0x27113777": {
      sig: "GuardiansNumberCannotGoBelowThreshold(uint256)",
      inputs: [
        { internalType: "uint256", name: "guardianThreshold", type: "uint256" },
      ],
      name: "GuardiansNumberCannotGoBelowThreshold",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when removing a guardian and the threshold is equal to the number of guardians",
        },
      ],
    },

    /**
     * error SecretHashCannotBeZero()
     *
     * 0x7f617002 = keccak256('SecretHashCannotBeZero()')
     */
    "0x7f617002": {
      sig: "SecretHashCannotBeZero()",
      inputs: [],
      name: "SecretHashCannotBeZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the secret hash provided is equal to bytes32(0)",
        },
      ],
    },

    /**
     * error ThresholdCannotBeHigherThanGuardiansNumber(
     *  uint256 thresholdGiven,
     *  uint256 guardianNumber
     * )
     *
     * 0xe3db80bd = keccak256('ThresholdCannotBeHigherThanGuardiansNumber(uint256,uint256)')
     */
    "0xe3db80bd": {
      sig: "ThresholdCannotBeHigherThanGuardiansNumber(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "thresholdGiven", type: "uint256" },
        { internalType: "uint256", name: "guardianNumber", type: "uint256" },
      ],
      name: "ThresholdCannotBeHigherThanGuardiansNumber",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when setting the guardians threshold to a number higher than the guardians number",
        },
      ],
    },

    /**
     * error ThresholdNotReachedForRecoverer(
     *  address recoverer,
     *  uint256 selections,
     *  uint256 guardiansThreshold
     * )
     *
     * 0xf78f0507 = keccak256('ThresholdNotReachedForRecoverer(address,uint256,uint256)')
     */
    "0xf78f0507": {
      sig: "ThresholdNotReachedForRecoverer(address,uint256,uint256)",
      inputs: [
        { internalType: "address", name: "recoverer", type: "address" },
        { internalType: "uint256", name: "selections", type: "uint256" },
        {
          internalType: "uint256",
          name: "guardiansThreshold",
          type: "uint256",
        },
      ],
      name: "ThresholdNotReachedForRecoverer",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `recoverOwnership(..)` is called with a recoverer that didn't reach the guardians threshold",
          params: {
            guardiansThreshold: "The minimum number of selection needed",
            recoverer: "The address of the recoverer",
            selections: "The number of selections that the recoverer have",
          },
        },
      ],
    },

    /**
     * error WrongPlainSecret()
     *
     * 0x6fa723c3 = keccak256('WrongPlainSecret()')
     */
    "0x6fa723c3": {
      sig: "WrongPlainSecret()",
      inputs: [],
      name: "WrongPlainSecret",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the plain secret produce a different hash than the secret hash originally set",
        },
      ],
    },
  },
  LSP11BasicSocialRecoveryInit: {
    /**
     * error AddressZeroNotAllowed()
     *
     * 0x0855380c = keccak256('AddressZeroNotAllowed()')
     */
    "0x0855380c": {
      sig: "AddressZeroNotAllowed()",
      inputs: [],
      name: "AddressZeroNotAllowed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the address zero calls `recoverOwnership(..)` function",
        },
      ],
    },

    /**
     * error CallerIsNotGuardian(
     *  address caller
     * )
     *
     * 0x5560e16d = keccak256('CallerIsNotGuardian(address)')
     */
    "0x5560e16d": {
      sig: "CallerIsNotGuardian(address)",
      inputs: [{ internalType: "address", name: "caller", type: "address" }],
      name: "CallerIsNotGuardian",
      type: "error",
      userdoc: [{ details: "reverts when the caller is not a guardian" }],
    },

    /**
     * error GuardianAlreadyExist(
     *  address addressToAdd
     * )
     *
     * 0xd52858db = keccak256('GuardianAlreadyExist(address)')
     */
    "0xd52858db": {
      sig: "GuardianAlreadyExist(address)",
      inputs: [
        { internalType: "address", name: "addressToAdd", type: "address" },
      ],
      name: "GuardianAlreadyExist",
      type: "error",
      userdoc: [
        { details: "reverts when adding an already existing guardian" },
      ],
    },

    /**
     * error GuardianDoNotExist(
     *  address addressToRemove
     * )
     *
     * 0x3d8e524e = keccak256('GuardianDoNotExist(address)')
     */
    "0x3d8e524e": {
      sig: "GuardianDoNotExist(address)",
      inputs: [
        { internalType: "address", name: "addressToRemove", type: "address" },
      ],
      name: "GuardianDoNotExist",
      type: "error",
      userdoc: [{ details: "reverts when removing a non-existing guardian" }],
    },

    /**
     * error GuardiansNumberCannotGoBelowThreshold(
     *  uint256 guardianThreshold
     * )
     *
     * 0x27113777 = keccak256('GuardiansNumberCannotGoBelowThreshold(uint256)')
     */
    "0x27113777": {
      sig: "GuardiansNumberCannotGoBelowThreshold(uint256)",
      inputs: [
        { internalType: "uint256", name: "guardianThreshold", type: "uint256" },
      ],
      name: "GuardiansNumberCannotGoBelowThreshold",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when removing a guardian and the threshold is equal to the number of guardians",
        },
      ],
    },

    /**
     * error SecretHashCannotBeZero()
     *
     * 0x7f617002 = keccak256('SecretHashCannotBeZero()')
     */
    "0x7f617002": {
      sig: "SecretHashCannotBeZero()",
      inputs: [],
      name: "SecretHashCannotBeZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the secret hash provided is equal to bytes32(0)",
        },
      ],
    },

    /**
     * error ThresholdCannotBeHigherThanGuardiansNumber(
     *  uint256 thresholdGiven,
     *  uint256 guardianNumber
     * )
     *
     * 0xe3db80bd = keccak256('ThresholdCannotBeHigherThanGuardiansNumber(uint256,uint256)')
     */
    "0xe3db80bd": {
      sig: "ThresholdCannotBeHigherThanGuardiansNumber(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "thresholdGiven", type: "uint256" },
        { internalType: "uint256", name: "guardianNumber", type: "uint256" },
      ],
      name: "ThresholdCannotBeHigherThanGuardiansNumber",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when setting the guardians threshold to a number higher than the guardians number",
        },
      ],
    },

    /**
     * error ThresholdNotReachedForRecoverer(
     *  address recoverer,
     *  uint256 selections,
     *  uint256 guardiansThreshold
     * )
     *
     * 0xf78f0507 = keccak256('ThresholdNotReachedForRecoverer(address,uint256,uint256)')
     */
    "0xf78f0507": {
      sig: "ThresholdNotReachedForRecoverer(address,uint256,uint256)",
      inputs: [
        { internalType: "address", name: "recoverer", type: "address" },
        { internalType: "uint256", name: "selections", type: "uint256" },
        {
          internalType: "uint256",
          name: "guardiansThreshold",
          type: "uint256",
        },
      ],
      name: "ThresholdNotReachedForRecoverer",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `recoverOwnership(..)` is called with a recoverer that didn't reach the guardians threshold",
          params: {
            guardiansThreshold: "The minimum number of selection needed",
            recoverer: "The address of the recoverer",
            selections: "The number of selections that the recoverer have",
          },
        },
      ],
    },

    /**
     * error WrongPlainSecret()
     *
     * 0x6fa723c3 = keccak256('WrongPlainSecret()')
     */
    "0x6fa723c3": {
      sig: "WrongPlainSecret()",
      inputs: [],
      name: "WrongPlainSecret",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the plain secret produce a different hash than the secret hash originally set",
        },
      ],
    },
  },
  LSP16UniversalFactory: {
    /**
     * error ContractInitializationFailed()
     *
     * 0xc1ee8543 = keccak256('ContractInitializationFailed()')
     */
    "0xc1ee8543": {
      sig: "ContractInitializationFailed()",
      inputs: [],
      name: "ContractInitializationFailed",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when there is no revert reason bubbled up by the contract created when initializing",
        },
      ],
    },

    /**
     * error InvalidValueSum()
     *
     * 0x2fd9ca91 = keccak256('InvalidValueSum()')
     */
    "0x2fd9ca91": {
      sig: "InvalidValueSum()",
      inputs: [],
      name: "InvalidValueSum",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when msg.value sent to {deployCreate2AndInitialize} function is not equal to the sum of the `initializeCalldataMsgValue` and `constructorMsgValue`",
        },
      ],
    },
  },
  LSP1UniversalReceiverDelegateUP: {
    /**
     * error CannotRegisterEOAsAsAssets(
     *  address caller
     * )
     *
     * 0xa5295345 = keccak256('CannotRegisterEOAsAsAssets(address)')
     */
    "0xa5295345": {
      sig: "CannotRegisterEOAsAsAssets(address)",
      inputs: [{ internalType: "address", name: "caller", type: "address" }],
      name: "CannotRegisterEOAsAsAssets",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when EOA calls the `universalReceiver(..)` function with an asset/vault typeId",
          params: { caller: "The address of the EOA" },
        },
      ],
    },

    /**
     * error InvalidLSP10ReceivedVaultsArrayLength(
     *  bytes invalidValueStored,
     *  uint256 invalidValueLength
     * )
     *
     * 0x12ce1c39 = keccak256('InvalidLSP10ReceivedVaultsArrayLength(bytes,uint256)')
     */
    "0x12ce1c39": {
      sig: "InvalidLSP10ReceivedVaultsArrayLength(bytes,uint256)",
      inputs: [
        { internalType: "bytes", name: "invalidValueStored", type: "bytes" },
        {
          internalType: "uint256",
          name: "invalidValueLength",
          type: "uint256",
        },
      ],
      name: "InvalidLSP10ReceivedVaultsArrayLength",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the value stored under the 'LSP10ReceivedVaults[]' data key is not valid.      The value stored under this data key should be exactly 16 bytes long.      Only possible valid values are:      - any valid uint128 values          i.e. 0x00000000000000000000000000000000 (zero), meaning empty array, no vaults received.          i.e. 0x00000000000000000000000000000005 (non-zero), meaning 5 array elements, 5 vaults received.      - 0x (nothing stored under this data key, equivalent to empty array)",
          params: {
            invalidValueLength:
              "the invalid number of bytes stored under the LSP10ReceivedVaults[] data key (MUST be 16 bytes long)",
            invalidValueStored:
              "the invalid value stored under the LSP10ReceivedVaults[] data key",
          },
        },
      ],
    },

    /**
     * error InvalidLSP5ReceivedAssetsArrayLength(
     *  bytes invalidValueStored,
     *  uint256 invalidValueLength
     * )
     *
     * 0xecba7af8 = keccak256('InvalidLSP5ReceivedAssetsArrayLength(bytes,uint256)')
     */
    "0xecba7af8": {
      sig: "InvalidLSP5ReceivedAssetsArrayLength(bytes,uint256)",
      inputs: [
        { internalType: "bytes", name: "invalidValueStored", type: "bytes" },
        {
          internalType: "uint256",
          name: "invalidValueLength",
          type: "uint256",
        },
      ],
      name: "InvalidLSP5ReceivedAssetsArrayLength",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the value stored under the 'LSP5ReceivedAssets[]' data key is not valid.      The value stored under this data key should be exactly 16 bytes long.      Only possible valid values are:      - any valid uint128 values          i.e. 0x00000000000000000000000000000000 (zero), empty array, no assets received.          i.e. 0x00000000000000000000000000000005 (non-zero), 5 array elements, 5 assets received.      - 0x (nothing stored under this data key, equivalent to empty array)",
          params: {
            invalidValueLength:
              "the invalid number of bytes stored under the LSP5ReceivedAssets[] data key (MUST be exactly 16 bytes long)",
            invalidValueStored:
              "the invalid value stored under the LSP5ReceivedAssets[] data key",
          },
        },
      ],
    },

    /**
     * error MaxLSP10VaultsCountReached(
     *  address notRegisteredVault
     * )
     *
     * 0x11610270 = keccak256('MaxLSP10VaultsCountReached(address)')
     */
    "0x11610270": {
      sig: "MaxLSP10VaultsCountReached(address)",
      inputs: [
        {
          internalType: "address",
          name: "notRegisteredVault",
          type: "address",
        },
      ],
      name: "MaxLSP10VaultsCountReached",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `LSP10Vaults[]` array reaches its maximum limit (max(uint128))",
          params: {
            notRegisteredVault:
              "the address of the vault that could not be registered",
          },
        },
      ],
    },

    /**
     * error MaxLSP5ReceivedAssetsCountReached(
     *  address notRegisteredAsset
     * )
     *
     * 0x0b51a2d0 = keccak256('MaxLSP5ReceivedAssetsCountReached(address)')
     */
    "0x0b51a2d0": {
      sig: "MaxLSP5ReceivedAssetsCountReached(address)",
      inputs: [
        {
          internalType: "address",
          name: "notRegisteredAsset",
          type: "address",
        },
      ],
      name: "MaxLSP5ReceivedAssetsCountReached",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `LSP5ReceivedAssets[]` array reaches its maximum limit (max(uint128))",
          params: {
            notRegisteredAsset:
              "the address of the asset that could not be registered",
          },
        },
      ],
    },

    /**
     * error NativeTokensNotAccepted()
     *
     * 0x114b721a = keccak256('NativeTokensNotAccepted()')
     */
    "0x114b721a": {
      sig: "NativeTokensNotAccepted()",
      inputs: [],
      name: "NativeTokensNotAccepted",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `universalReceiver(...)` is called with a value different than 0",
        },
      ],
    },

    /**
     * error ReceivedAssetsIndexSuperiorToUint128(
     *  uint256 index
     * )
     *
     * 0xe8a4fba0 = keccak256('ReceivedAssetsIndexSuperiorToUint128(uint256)')
     */
    "0xe8a4fba0": {
      sig: "ReceivedAssetsIndexSuperiorToUint128(uint256)",
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "ReceivedAssetsIndexSuperiorToUint128",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the received assets index is superior to uint128",
          params: { index: "the received assets index" },
        },
      ],
    },

    /**
     * error VaultIndexSuperiorToUint128(
     *  uint256 index
     * )
     *
     * 0x76f9db1b = keccak256('VaultIndexSuperiorToUint128(uint256)')
     */
    "0x76f9db1b": {
      sig: "VaultIndexSuperiorToUint128(uint256)",
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "VaultIndexSuperiorToUint128",
      type: "error",
      userdoc: [
        {
          details: "reverts when the vault index is superior to uint128",
          params: { index: "the vault index" },
        },
      ],
    },
  },
  LSP1UniversalReceiverDelegateVault: {
    /**
     * error CannotRegisterEOAsAsAssets(
     *  address caller
     * )
     *
     * 0xa5295345 = keccak256('CannotRegisterEOAsAsAssets(address)')
     */
    "0xa5295345": {
      sig: "CannotRegisterEOAsAsAssets(address)",
      inputs: [{ internalType: "address", name: "caller", type: "address" }],
      name: "CannotRegisterEOAsAsAssets",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when EOA calls the `universalReceiver(..)` function with an asset/vault typeId",
          params: { caller: "The address of the EOA" },
        },
      ],
    },

    /**
     * error InvalidLSP5ReceivedAssetsArrayLength(
     *  bytes invalidValueStored,
     *  uint256 invalidValueLength
     * )
     *
     * 0xecba7af8 = keccak256('InvalidLSP5ReceivedAssetsArrayLength(bytes,uint256)')
     */
    "0xecba7af8": {
      sig: "InvalidLSP5ReceivedAssetsArrayLength(bytes,uint256)",
      inputs: [
        { internalType: "bytes", name: "invalidValueStored", type: "bytes" },
        {
          internalType: "uint256",
          name: "invalidValueLength",
          type: "uint256",
        },
      ],
      name: "InvalidLSP5ReceivedAssetsArrayLength",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the value stored under the 'LSP5ReceivedAssets[]' data key is not valid.      The value stored under this data key should be exactly 16 bytes long.      Only possible valid values are:      - any valid uint128 values          i.e. 0x00000000000000000000000000000000 (zero), empty array, no assets received.          i.e. 0x00000000000000000000000000000005 (non-zero), 5 array elements, 5 assets received.      - 0x (nothing stored under this data key, equivalent to empty array)",
          params: {
            invalidValueLength:
              "the invalid number of bytes stored under the LSP5ReceivedAssets[] data key (MUST be exactly 16 bytes long)",
            invalidValueStored:
              "the invalid value stored under the LSP5ReceivedAssets[] data key",
          },
        },
      ],
    },

    /**
     * error MaxLSP5ReceivedAssetsCountReached(
     *  address notRegisteredAsset
     * )
     *
     * 0x0b51a2d0 = keccak256('MaxLSP5ReceivedAssetsCountReached(address)')
     */
    "0x0b51a2d0": {
      sig: "MaxLSP5ReceivedAssetsCountReached(address)",
      inputs: [
        {
          internalType: "address",
          name: "notRegisteredAsset",
          type: "address",
        },
      ],
      name: "MaxLSP5ReceivedAssetsCountReached",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `LSP5ReceivedAssets[]` array reaches its maximum limit (max(uint128))",
          params: {
            notRegisteredAsset:
              "the address of the asset that could not be registered",
          },
        },
      ],
    },

    /**
     * error NativeTokensNotAccepted()
     *
     * 0x114b721a = keccak256('NativeTokensNotAccepted()')
     */
    "0x114b721a": {
      sig: "NativeTokensNotAccepted()",
      inputs: [],
      name: "NativeTokensNotAccepted",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `universalReceiver(...)` is called with a value different than 0",
        },
      ],
    },

    /**
     * error ReceivedAssetsIndexSuperiorToUint128(
     *  uint256 index
     * )
     *
     * 0xe8a4fba0 = keccak256('ReceivedAssetsIndexSuperiorToUint128(uint256)')
     */
    "0xe8a4fba0": {
      sig: "ReceivedAssetsIndexSuperiorToUint128(uint256)",
      inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
      name: "ReceivedAssetsIndexSuperiorToUint128",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the received assets index is superior to uint128",
          params: { index: "the received assets index" },
        },
      ],
    },
  },
  LSP4Compatibility: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },
  },
  LSP4DigitalAssetMetadata: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },
  },
  LSP4DigitalAssetMetadataInitAbstract: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },
  },
  LSP6KeyManager: {
    /**
     * error AddressPermissionArrayIndexValueNotAnAddress(
     *  bytes32 dataKey,
     *  bytes invalidValue
     * )
     *
     * 0x8f4afa38 = keccak256('AddressPermissionArrayIndexValueNotAnAddress(bytes32,bytes)')
     */
    "0x8f4afa38": {
      sig: "AddressPermissionArrayIndexValueNotAnAddress(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "invalidValue", type: "bytes" },
      ],
      name: "AddressPermissionArrayIndexValueNotAnAddress",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set a value that is not 20 bytes long under AddressPermissions[index]",
          params: {
            dataKey: "the AddressPermissions[index] data key",
            invalidValue:
              "the invalid value that was attempted to be set under AddressPermissions[index]",
          },
        },
      ],
    },

    /**
     * error BatchExecuteParamsLengthMismatch()
     *
     * 0x55a187db = keccak256('BatchExecuteParamsLengthMismatch()')
     */
    "0x55a187db": {
      sig: "BatchExecuteParamsLengthMismatch()",
      inputs: [],
      name: "BatchExecuteParamsLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "there should be the same number of elements for each array parameters in the following batch functions:  - execute(uint256[],bytes[])  - executeRelayCall(bytes[],uint256[],uint256[],bytes[])",
        },
      ],
    },

    /**
     * error BatchExecuteRelayCallParamsLengthMismatch()
     *
     * 0xb4d50d21 = keccak256('BatchExecuteRelayCallParamsLengthMismatch()')
     */
    "0xb4d50d21": {
      sig: "BatchExecuteRelayCallParamsLengthMismatch()",
      inputs: [],
      name: "BatchExecuteRelayCallParamsLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when providing array parameters of different sizes to `executeRelayCall(bytes[],uint256[],bytes[])`",
        },
      ],
    },

    /**
     * error CallingKeyManagerNotAllowed()
     *
     * 0xa431b236 = keccak256('CallingKeyManagerNotAllowed()')
     */
    "0xa431b236": {
      sig: "CallingKeyManagerNotAllowed()",
      inputs: [],
      name: "CallingKeyManagerNotAllowed",
      type: "error",
      userdoc: [
        { details: "reverts when calling the KeyManager through execute(..)" },
      ],
    },

    /**
     * error CannotSendValueToSetData()
     *
     * 0x59a529fc = keccak256('CannotSendValueToSetData()')
     */
    "0x59a529fc": {
      sig: "CannotSendValueToSetData()",
      inputs: [],
      name: "CannotSendValueToSetData",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error DelegateCallDisallowedViaKeyManager()
     *
     * 0x80d6ebae = keccak256('DelegateCallDisallowedViaKeyManager()')
     */
    "0x80d6ebae": {
      sig: "DelegateCallDisallowedViaKeyManager()",
      inputs: [],
      name: "DelegateCallDisallowedViaKeyManager",
      type: "error",
      userdoc: [
        {
          details:
            "ERC725X operation type 4 (DELEGATECALL) is disallowed by default",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error InvalidERC725Function(
     *  bytes4 invalidFunction
     * )
     *
     * 0x2ba8851c = keccak256('InvalidERC725Function(bytes4)')
     */
    "0x2ba8851c": {
      sig: "InvalidERC725Function(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "invalidFunction", type: "bytes4" },
      ],
      name: "InvalidERC725Function",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to run an invalid function on the linked target account via the Key Manager.",
          params: {
            invalidFunction: "the bytes4 selector of the invalid function",
          },
        },
      ],
    },

    /**
     * error InvalidEncodedAllowedCalls(
     *  bytes allowedCallsValue
     * )
     *
     * 0x187e77ab = keccak256('InvalidEncodedAllowedCalls(bytes)')
     */
    "0x187e77ab": {
      sig: "InvalidEncodedAllowedCalls(bytes)",
      inputs: [
        { internalType: "bytes", name: "allowedCallsValue", type: "bytes" },
      ],
      name: "InvalidEncodedAllowedCalls",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `allowedCallsValue` is not properly encoded as a bytes28[CompactBytesArray] (CompactBytesArray of bytes28 entries). See LSP2 value type `CompactBytesArray` for details.",
          params: { allowedCallsValue: "the list of allowedCalls" },
        },
      ],
    },

    /**
     * error InvalidEncodedAllowedERC725YDataKeys(
     *  bytes value,
     *  string context
     * )
     *
     * 0xae6cbd37 = keccak256('InvalidEncodedAllowedERC725YDataKeys(bytes,string)')
     */
    "0xae6cbd37": {
      sig: "InvalidEncodedAllowedERC725YDataKeys(bytes,string)",
      inputs: [
        { internalType: "bytes", name: "value", type: "bytes" },
        { internalType: "string", name: "context", type: "string" },
      ],
      name: "InvalidEncodedAllowedERC725YDataKeys",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `value` is not encoded properly using the CompactBytesArray",
          params: {
            context: "a brief description of where the error occured",
            value: "the value to check for an CompactBytesArray",
          },
        },
      ],
    },

    /**
     * error InvalidLSP6Target()
     *
     * 0xfc854579 = keccak256('InvalidLSP6Target()')
     */
    "0xfc854579": {
      sig: "InvalidLSP6Target()",
      inputs: [],
      name: "InvalidLSP6Target",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the address provided as a target (= account) linked to this KeyManager is invalid      e.g. address(0)",
        },
      ],
    },

    /**
     * error InvalidPayload(
     *  bytes payload
     * )
     *
     * 0x3621bbcc = keccak256('InvalidPayload(bytes)')
     */
    "0x3621bbcc": {
      sig: "InvalidPayload(bytes)",
      inputs: [{ internalType: "bytes", name: "payload", type: "bytes" }],
      name: "InvalidPayload",
      type: "error",
      userdoc: [{ details: "reverts when the payload is invalid." }],
    },

    /**
     * error InvalidRelayNonce(
     *  address signer,
     *  uint256 invalidNonce,
     *  bytes signature
     * )
     *
     * 0xc9bd9eb9 = keccak256('InvalidRelayNonce(address,uint256,bytes)')
     */
    "0xc9bd9eb9": {
      sig: "InvalidRelayNonce(address,uint256,bytes)",
      inputs: [
        { internalType: "address", name: "signer", type: "address" },
        { internalType: "uint256", name: "invalidNonce", type: "uint256" },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "InvalidRelayNonce",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `signer` address retrieved from the `signature` has an invalid nonce: `invalidNonce`.",
          params: {
            invalidNonce: "the nonce retrieved for the `signer` address",
            signature: "the signature used to retrieve the `signer` address",
            signer: "the address of the signer",
          },
        },
      ],
    },

    /**
     * error InvalidWhitelistedCall(
     *  address from
     * )
     *
     * 0x6fd203c5 = keccak256('InvalidWhitelistedCall(address)')
     */
    "0x6fd203c5": {
      sig: "InvalidWhitelistedCall(address)",
      inputs: [{ internalType: "address", name: "from", type: "address" }],
      name: "InvalidWhitelistedCall",
      type: "error",
      userdoc: [
        {
          details:
            "a `from` address is not allowed to have 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff in its list of AddressPermissions:AllowedCalls:<address>, as this allows any STANDARD:ADDRESS:FUNCTION. This is equivalent to granting the SUPER permission and should never be valid.",
          params: {
            from: "the address that has any allowed calls whitelisted.",
          },
        },
      ],
    },

    /**
     * error LSP6BatchExcessiveValueSent(
     *  uint256 totalValues,
     *  uint256 msgValue
     * )
     *
     * 0xa51868b6 = keccak256('LSP6BatchExcessiveValueSent(uint256,uint256)')
     */
    "0xa51868b6": {
      sig: "LSP6BatchExcessiveValueSent(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "totalValues", type: "uint256" },
        { internalType: "uint256", name: "msgValue", type: "uint256" },
      ],
      name: "LSP6BatchExcessiveValueSent",
      type: "error",
      userdoc: [
        {
          details:
            "reverts to avoid the KeyManager to holds some remaining funds sent to the following batch functions:  - execute(uint256[],bytes[])  - executeRelayCall(bytes[],uint256[],uint256[],bytes[]) This error occurs when `msg.value` is more than the sum of all the values being forwarded on each payloads (`values[]` parameter from the batch functions above).",
        },
      ],
    },

    /**
     * error LSP6BatchInsufficientValueSent(
     *  uint256 totalValues,
     *  uint256 msgValue
     * )
     *
     * 0x30a324ac = keccak256('LSP6BatchInsufficientValueSent(uint256,uint256)')
     */
    "0x30a324ac": {
      sig: "LSP6BatchInsufficientValueSent(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "totalValues", type: "uint256" },
        { internalType: "uint256", name: "msgValue", type: "uint256" },
      ],
      name: "LSP6BatchInsufficientValueSent",
      type: "error",
      userdoc: [
        {
          details:
            "the `msg.value` sent is not enough to cover the sum of all the values being forwarded on each payloads (`values[]` parameter) in the following batch functions:  - execute(uint256[],bytes[])  - executeRelayCall(bytes[],uint256[],uint256[],bytes[])",
        },
      ],
    },

    /**
     * error NoCallsAllowed(
     *  address from
     * )
     *
     * 0x6cb60587 = keccak256('NoCallsAllowed(address)')
     */
    "0x6cb60587": {
      sig: "NoCallsAllowed(address)",
      inputs: [{ internalType: "address", name: "from", type: "address" }],
      name: "NoCallsAllowed",
      type: "error",
      userdoc: [
        {
          details: "reverts if there are no allowed calls set for `from`",
          params: { from: "the address that has no AllowedCalls" },
        },
      ],
    },

    /**
     * error NoERC725YDataKeysAllowed(
     *  address from
     * )
     *
     * 0xed7fa509 = keccak256('NoERC725YDataKeysAllowed(address)')
     */
    "0xed7fa509": {
      sig: "NoERC725YDataKeysAllowed(address)",
      inputs: [{ internalType: "address", name: "from", type: "address" }],
      name: "NoERC725YDataKeysAllowed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if there are no AllowedERC725YDataKeys set for the caller",
          params: { from: "the address that has no AllowedERC725YDataKeys" },
        },
      ],
    },

    /**
     * error NoPermissionsSet(
     *  address from
     * )
     *
     * 0xf292052a = keccak256('NoPermissionsSet(address)')
     */
    "0xf292052a": {
      sig: "NoPermissionsSet(address)",
      inputs: [{ internalType: "address", name: "from", type: "address" }],
      name: "NoPermissionsSet",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when address `from` does not have any permissions set on the account linked to this Key Manager",
          params: { from: "the address that does not have permissions" },
        },
      ],
    },

    /**
     * error NotAllowedCall(
     *  address from,
     *  address to,
     *  bytes4 selector
     * )
     *
     * 0x45147bce = keccak256('NotAllowedCall(address,address,bytes4)')
     */
    "0x45147bce": {
      sig: "NotAllowedCall(address,address,bytes4)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes4", name: "selector", type: "bytes4" },
      ],
      name: "NotAllowedCall",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `from` is not authorised to make the call because of a not allowed standard, address or function.",
          params: {
            from: "address making the request",
            selector:
              "if `to` is a contract, the bytes4 selector of the function that `from` is trying to call. If no function is called (e.g: a native token transfer), selector = 0x00000000",
            to: "the address of an EOA or contract that `from` is trying to interact with",
          },
        },
      ],
    },

    /**
     * error NotAllowedERC725YDataKey(
     *  address from,
     *  bytes32 disallowedKey
     * )
     *
     * 0x557ae079 = keccak256('NotAllowedERC725YDataKey(address,bytes32)')
     */
    "0x557ae079": {
      sig: "NotAllowedERC725YDataKey(address,bytes32)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "bytes32", name: "disallowedKey", type: "bytes32" },
      ],
      name: "NotAllowedERC725YDataKey",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when address `from` is not authorised to set the key `disallowedKey` on the linked account",
          params: {
            disallowedKey:
              "a bytes32 key that `from` is not authorised to set on the ERC725Y storage",
            from: "address making the request",
          },
        },
      ],
    },

    /**
     * error NotAuthorised(
     *  address from,
     *  string permission
     * )
     *
     * 0x3bdad6e6 = keccak256('NotAuthorised(address,string)')
     */
    "0x3bdad6e6": {
      sig: "NotAuthorised(address,string)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "string", name: "permission", type: "string" },
      ],
      name: "NotAuthorised",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when address `from` is not authorised to perform `permission` on the linked account",
          params: {
            from: "address not-authorised",
            permission: "permission required",
          },
        },
      ],
    },

    /**
     * error NotRecognisedPermissionKey(
     *  bytes32 dataKey
     * )
     *
     * 0x0f7d735b = keccak256('NotRecognisedPermissionKey(bytes32)')
     */
    "0x0f7d735b": {
      sig: "NotRecognisedPermissionKey(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "NotRecognisedPermissionKey",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `dataKey` is a bytes32 that does not adhere to any of the      permission data keys specified by the LSP6 standard",
          params: {
            dataKey:
              "the dataKey that does not match with any of the standard LSP6 permission data keys",
          },
        },
      ],
    },

    /**
     * error RelayCallBeforeStartTime()
     *
     * 0x00de4b8a = keccak256('RelayCallBeforeStartTime()')
     */
    "0x00de4b8a": {
      sig: "RelayCallBeforeStartTime()",
      inputs: [],
      name: "RelayCallBeforeStartTime",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when relay call start timestamp is bigger than the current timestamp",
        },
      ],
    },

    /**
     * error RelayCallExpired()
     *
     * 0x5c53a98c = keccak256('RelayCallExpired()')
     */
    "0x5c53a98c": {
      sig: "RelayCallExpired()",
      inputs: [],
      name: "RelayCallExpired",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the period to execute the relay call has expired",
        },
      ],
    },
  },
  LSP6KeyManagerInit: {
    /**
     * error AddressPermissionArrayIndexValueNotAnAddress(
     *  bytes32 dataKey,
     *  bytes invalidValue
     * )
     *
     * 0x8f4afa38 = keccak256('AddressPermissionArrayIndexValueNotAnAddress(bytes32,bytes)')
     */
    "0x8f4afa38": {
      sig: "AddressPermissionArrayIndexValueNotAnAddress(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "invalidValue", type: "bytes" },
      ],
      name: "AddressPermissionArrayIndexValueNotAnAddress",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set a value that is not 20 bytes long under AddressPermissions[index]",
          params: {
            dataKey: "the AddressPermissions[index] data key",
            invalidValue:
              "the invalid value that was attempted to be set under AddressPermissions[index]",
          },
        },
      ],
    },

    /**
     * error BatchExecuteParamsLengthMismatch()
     *
     * 0x55a187db = keccak256('BatchExecuteParamsLengthMismatch()')
     */
    "0x55a187db": {
      sig: "BatchExecuteParamsLengthMismatch()",
      inputs: [],
      name: "BatchExecuteParamsLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "there should be the same number of elements for each array parameters in the following batch functions:  - execute(uint256[],bytes[])  - executeRelayCall(bytes[],uint256[],uint256[],bytes[])",
        },
      ],
    },

    /**
     * error BatchExecuteRelayCallParamsLengthMismatch()
     *
     * 0xb4d50d21 = keccak256('BatchExecuteRelayCallParamsLengthMismatch()')
     */
    "0xb4d50d21": {
      sig: "BatchExecuteRelayCallParamsLengthMismatch()",
      inputs: [],
      name: "BatchExecuteRelayCallParamsLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when providing array parameters of different sizes to `executeRelayCall(bytes[],uint256[],bytes[])`",
        },
      ],
    },

    /**
     * error CallingKeyManagerNotAllowed()
     *
     * 0xa431b236 = keccak256('CallingKeyManagerNotAllowed()')
     */
    "0xa431b236": {
      sig: "CallingKeyManagerNotAllowed()",
      inputs: [],
      name: "CallingKeyManagerNotAllowed",
      type: "error",
      userdoc: [
        { details: "reverts when calling the KeyManager through execute(..)" },
      ],
    },

    /**
     * error CannotSendValueToSetData()
     *
     * 0x59a529fc = keccak256('CannotSendValueToSetData()')
     */
    "0x59a529fc": {
      sig: "CannotSendValueToSetData()",
      inputs: [],
      name: "CannotSendValueToSetData",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error DelegateCallDisallowedViaKeyManager()
     *
     * 0x80d6ebae = keccak256('DelegateCallDisallowedViaKeyManager()')
     */
    "0x80d6ebae": {
      sig: "DelegateCallDisallowedViaKeyManager()",
      inputs: [],
      name: "DelegateCallDisallowedViaKeyManager",
      type: "error",
      userdoc: [
        {
          details:
            "ERC725X operation type 4 (DELEGATECALL) is disallowed by default",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error InvalidERC725Function(
     *  bytes4 invalidFunction
     * )
     *
     * 0x2ba8851c = keccak256('InvalidERC725Function(bytes4)')
     */
    "0x2ba8851c": {
      sig: "InvalidERC725Function(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "invalidFunction", type: "bytes4" },
      ],
      name: "InvalidERC725Function",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to run an invalid function on the linked target account via the Key Manager.",
          params: {
            invalidFunction: "the bytes4 selector of the invalid function",
          },
        },
      ],
    },

    /**
     * error InvalidEncodedAllowedCalls(
     *  bytes allowedCallsValue
     * )
     *
     * 0x187e77ab = keccak256('InvalidEncodedAllowedCalls(bytes)')
     */
    "0x187e77ab": {
      sig: "InvalidEncodedAllowedCalls(bytes)",
      inputs: [
        { internalType: "bytes", name: "allowedCallsValue", type: "bytes" },
      ],
      name: "InvalidEncodedAllowedCalls",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `allowedCallsValue` is not properly encoded as a bytes28[CompactBytesArray] (CompactBytesArray of bytes28 entries). See LSP2 value type `CompactBytesArray` for details.",
          params: { allowedCallsValue: "the list of allowedCalls" },
        },
      ],
    },

    /**
     * error InvalidEncodedAllowedERC725YDataKeys(
     *  bytes value,
     *  string context
     * )
     *
     * 0xae6cbd37 = keccak256('InvalidEncodedAllowedERC725YDataKeys(bytes,string)')
     */
    "0xae6cbd37": {
      sig: "InvalidEncodedAllowedERC725YDataKeys(bytes,string)",
      inputs: [
        { internalType: "bytes", name: "value", type: "bytes" },
        { internalType: "string", name: "context", type: "string" },
      ],
      name: "InvalidEncodedAllowedERC725YDataKeys",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `value` is not encoded properly using the CompactBytesArray",
          params: {
            context: "a brief description of where the error occured",
            value: "the value to check for an CompactBytesArray",
          },
        },
      ],
    },

    /**
     * error InvalidLSP6Target()
     *
     * 0xfc854579 = keccak256('InvalidLSP6Target()')
     */
    "0xfc854579": {
      sig: "InvalidLSP6Target()",
      inputs: [],
      name: "InvalidLSP6Target",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the address provided as a target (= account) linked to this KeyManager is invalid      e.g. address(0)",
        },
      ],
    },

    /**
     * error InvalidPayload(
     *  bytes payload
     * )
     *
     * 0x3621bbcc = keccak256('InvalidPayload(bytes)')
     */
    "0x3621bbcc": {
      sig: "InvalidPayload(bytes)",
      inputs: [{ internalType: "bytes", name: "payload", type: "bytes" }],
      name: "InvalidPayload",
      type: "error",
      userdoc: [{ details: "reverts when the payload is invalid." }],
    },

    /**
     * error InvalidRelayNonce(
     *  address signer,
     *  uint256 invalidNonce,
     *  bytes signature
     * )
     *
     * 0xc9bd9eb9 = keccak256('InvalidRelayNonce(address,uint256,bytes)')
     */
    "0xc9bd9eb9": {
      sig: "InvalidRelayNonce(address,uint256,bytes)",
      inputs: [
        { internalType: "address", name: "signer", type: "address" },
        { internalType: "uint256", name: "invalidNonce", type: "uint256" },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "InvalidRelayNonce",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `signer` address retrieved from the `signature` has an invalid nonce: `invalidNonce`.",
          params: {
            invalidNonce: "the nonce retrieved for the `signer` address",
            signature: "the signature used to retrieve the `signer` address",
            signer: "the address of the signer",
          },
        },
      ],
    },

    /**
     * error InvalidWhitelistedCall(
     *  address from
     * )
     *
     * 0x6fd203c5 = keccak256('InvalidWhitelistedCall(address)')
     */
    "0x6fd203c5": {
      sig: "InvalidWhitelistedCall(address)",
      inputs: [{ internalType: "address", name: "from", type: "address" }],
      name: "InvalidWhitelistedCall",
      type: "error",
      userdoc: [
        {
          details:
            "a `from` address is not allowed to have 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff in its list of AddressPermissions:AllowedCalls:<address>, as this allows any STANDARD:ADDRESS:FUNCTION. This is equivalent to granting the SUPER permission and should never be valid.",
          params: {
            from: "the address that has any allowed calls whitelisted.",
          },
        },
      ],
    },

    /**
     * error LSP6BatchExcessiveValueSent(
     *  uint256 totalValues,
     *  uint256 msgValue
     * )
     *
     * 0xa51868b6 = keccak256('LSP6BatchExcessiveValueSent(uint256,uint256)')
     */
    "0xa51868b6": {
      sig: "LSP6BatchExcessiveValueSent(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "totalValues", type: "uint256" },
        { internalType: "uint256", name: "msgValue", type: "uint256" },
      ],
      name: "LSP6BatchExcessiveValueSent",
      type: "error",
      userdoc: [
        {
          details:
            "reverts to avoid the KeyManager to holds some remaining funds sent to the following batch functions:  - execute(uint256[],bytes[])  - executeRelayCall(bytes[],uint256[],uint256[],bytes[]) This error occurs when `msg.value` is more than the sum of all the values being forwarded on each payloads (`values[]` parameter from the batch functions above).",
        },
      ],
    },

    /**
     * error LSP6BatchInsufficientValueSent(
     *  uint256 totalValues,
     *  uint256 msgValue
     * )
     *
     * 0x30a324ac = keccak256('LSP6BatchInsufficientValueSent(uint256,uint256)')
     */
    "0x30a324ac": {
      sig: "LSP6BatchInsufficientValueSent(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "totalValues", type: "uint256" },
        { internalType: "uint256", name: "msgValue", type: "uint256" },
      ],
      name: "LSP6BatchInsufficientValueSent",
      type: "error",
      userdoc: [
        {
          details:
            "the `msg.value` sent is not enough to cover the sum of all the values being forwarded on each payloads (`values[]` parameter) in the following batch functions:  - execute(uint256[],bytes[])  - executeRelayCall(bytes[],uint256[],uint256[],bytes[])",
        },
      ],
    },

    /**
     * error NoCallsAllowed(
     *  address from
     * )
     *
     * 0x6cb60587 = keccak256('NoCallsAllowed(address)')
     */
    "0x6cb60587": {
      sig: "NoCallsAllowed(address)",
      inputs: [{ internalType: "address", name: "from", type: "address" }],
      name: "NoCallsAllowed",
      type: "error",
      userdoc: [
        {
          details: "reverts if there are no allowed calls set for `from`",
          params: { from: "the address that has no AllowedCalls" },
        },
      ],
    },

    /**
     * error NoERC725YDataKeysAllowed(
     *  address from
     * )
     *
     * 0xed7fa509 = keccak256('NoERC725YDataKeysAllowed(address)')
     */
    "0xed7fa509": {
      sig: "NoERC725YDataKeysAllowed(address)",
      inputs: [{ internalType: "address", name: "from", type: "address" }],
      name: "NoERC725YDataKeysAllowed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if there are no AllowedERC725YDataKeys set for the caller",
          params: { from: "the address that has no AllowedERC725YDataKeys" },
        },
      ],
    },

    /**
     * error NoPermissionsSet(
     *  address from
     * )
     *
     * 0xf292052a = keccak256('NoPermissionsSet(address)')
     */
    "0xf292052a": {
      sig: "NoPermissionsSet(address)",
      inputs: [{ internalType: "address", name: "from", type: "address" }],
      name: "NoPermissionsSet",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when address `from` does not have any permissions set on the account linked to this Key Manager",
          params: { from: "the address that does not have permissions" },
        },
      ],
    },

    /**
     * error NotAllowedCall(
     *  address from,
     *  address to,
     *  bytes4 selector
     * )
     *
     * 0x45147bce = keccak256('NotAllowedCall(address,address,bytes4)')
     */
    "0x45147bce": {
      sig: "NotAllowedCall(address,address,bytes4)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes4", name: "selector", type: "bytes4" },
      ],
      name: "NotAllowedCall",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `from` is not authorised to make the call because of a not allowed standard, address or function.",
          params: {
            from: "address making the request",
            selector:
              "if `to` is a contract, the bytes4 selector of the function that `from` is trying to call. If no function is called (e.g: a native token transfer), selector = 0x00000000",
            to: "the address of an EOA or contract that `from` is trying to interact with",
          },
        },
      ],
    },

    /**
     * error NotAllowedERC725YDataKey(
     *  address from,
     *  bytes32 disallowedKey
     * )
     *
     * 0x557ae079 = keccak256('NotAllowedERC725YDataKey(address,bytes32)')
     */
    "0x557ae079": {
      sig: "NotAllowedERC725YDataKey(address,bytes32)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "bytes32", name: "disallowedKey", type: "bytes32" },
      ],
      name: "NotAllowedERC725YDataKey",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when address `from` is not authorised to set the key `disallowedKey` on the linked account",
          params: {
            disallowedKey:
              "a bytes32 key that `from` is not authorised to set on the ERC725Y storage",
            from: "address making the request",
          },
        },
      ],
    },

    /**
     * error NotAuthorised(
     *  address from,
     *  string permission
     * )
     *
     * 0x3bdad6e6 = keccak256('NotAuthorised(address,string)')
     */
    "0x3bdad6e6": {
      sig: "NotAuthorised(address,string)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "string", name: "permission", type: "string" },
      ],
      name: "NotAuthorised",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when address `from` is not authorised to perform `permission` on the linked account",
          params: {
            from: "address not-authorised",
            permission: "permission required",
          },
        },
      ],
    },

    /**
     * error NotRecognisedPermissionKey(
     *  bytes32 dataKey
     * )
     *
     * 0x0f7d735b = keccak256('NotRecognisedPermissionKey(bytes32)')
     */
    "0x0f7d735b": {
      sig: "NotRecognisedPermissionKey(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "NotRecognisedPermissionKey",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `dataKey` is a bytes32 that does not adhere to any of the      permission data keys specified by the LSP6 standard",
          params: {
            dataKey:
              "the dataKey that does not match with any of the standard LSP6 permission data keys",
          },
        },
      ],
    },

    /**
     * error RelayCallBeforeStartTime()
     *
     * 0x00de4b8a = keccak256('RelayCallBeforeStartTime()')
     */
    "0x00de4b8a": {
      sig: "RelayCallBeforeStartTime()",
      inputs: [],
      name: "RelayCallBeforeStartTime",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when relay call start timestamp is bigger than the current timestamp",
        },
      ],
    },

    /**
     * error RelayCallExpired()
     *
     * 0x5c53a98c = keccak256('RelayCallExpired()')
     */
    "0x5c53a98c": {
      sig: "RelayCallExpired()",
      inputs: [],
      name: "RelayCallExpired",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the period to execute the relay call has expired",
        },
      ],
    },
  },
  LSP7DigitalAsset: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP7DigitalAssetInitAbstract: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP7CappedSupply: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7CappedSupplyCannotMintOverCap()
     *
     * 0xeacbf0d1 = keccak256('LSP7CappedSupplyCannotMintOverCap()')
     */
    "0xeacbf0d1": {
      sig: "LSP7CappedSupplyCannotMintOverCap()",
      inputs: [],
      name: "LSP7CappedSupplyCannotMintOverCap",
      type: "error",
    },

    /**
     * error LSP7CappedSupplyRequired()
     *
     * 0xacf1d8c5 = keccak256('LSP7CappedSupplyRequired()')
     */
    "0xacf1d8c5": {
      sig: "LSP7CappedSupplyRequired()",
      inputs: [],
      name: "LSP7CappedSupplyRequired",
      type: "error",
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP7CappedSupplyInitAbstract: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7CappedSupplyCannotMintOverCap()
     *
     * 0xeacbf0d1 = keccak256('LSP7CappedSupplyCannotMintOverCap()')
     */
    "0xeacbf0d1": {
      sig: "LSP7CappedSupplyCannotMintOverCap()",
      inputs: [],
      name: "LSP7CappedSupplyCannotMintOverCap",
      type: "error",
    },

    /**
     * error LSP7CappedSupplyRequired()
     *
     * 0xacf1d8c5 = keccak256('LSP7CappedSupplyRequired()')
     */
    "0xacf1d8c5": {
      sig: "LSP7CappedSupplyRequired()",
      inputs: [],
      name: "LSP7CappedSupplyRequired",
      type: "error",
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP7CompatibleERC20: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP7CompatibleERC20InitAbstract: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP7CompatibleERC20Mintable: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP7CompatibleERC20MintableInit: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP7Mintable: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP7MintableInit: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsAuthorizedAmount(
     *  address tokenOwner,
     *  uint256 authorizedAmount,
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0xf3a6b691 = keccak256('LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)')
     */
    "0xf3a6b691": {
      sig: "LSP7AmountExceedsAuthorizedAmount(address,uint256,address,uint256)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "authorizedAmount", type: "uint256" },
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsAuthorizedAmount",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` of `tokenOwner` send an `amount` of tokens larger than the `authorizedAmount`.",
        },
      ],
    },

    /**
     * error LSP7AmountExceedsBalance(
     *  uint256 balance,
     *  address tokenOwner,
     *  uint256 amount
     * )
     *
     * 0x08d47949 = keccak256('LSP7AmountExceedsBalance(uint256,address,uint256)')
     */
    "0x08d47949": {
      sig: "LSP7AmountExceedsBalance(uint256,address,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "LSP7AmountExceedsBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when sending an `amount` of tokens larger than the current `balance` of the `tokenOwner`.",
        },
      ],
    },

    /**
     * error LSP7CannotSendToSelf()
     *
     * 0xb9afb000 = keccak256('LSP7CannotSendToSelf()')
     */
    "0xb9afb000": {
      sig: "LSP7CannotSendToSelf()",
      inputs: [],
      name: "LSP7CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` or `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP7CannotSendWithAddressZero()
     *
     * 0xd2d5ec30 = keccak256('LSP7CannotSendWithAddressZero()')
     */
    "0xd2d5ec30": {
      sig: "LSP7CannotSendWithAddressZero()",
      inputs: [],
      name: "LSP7CannotSendWithAddressZero",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one tries to send tokens to or from the zero address.",
        },
      ],
    },

    /**
     * error LSP7CannotUseAddressZeroAsOperator()
     *
     * 0x6355e766 = keccak256('LSP7CannotUseAddressZeroAsOperator()')
     */
    "0x6355e766": {
      sig: "LSP7CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP7CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP7DecreasedAllowanceBelowZero()
     *
     * 0x0ef76c35 = keccak256('LSP7DecreasedAllowanceBelowZero()')
     */
    "0x0ef76c35": {
      sig: "LSP7DecreasedAllowanceBelowZero()",
      inputs: [],
      name: "LSP7DecreasedAllowanceBelowZero",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to decrease an operator's allowance to more than his current allowance",
        },
      ],
    },

    /**
     * error LSP7InvalidTransferBatch()
     *
     * 0x263eee8d = keccak256('LSP7InvalidTransferBatch()')
     */
    "0x263eee8d": {
      sig: "LSP7InvalidTransferBatch()",
      inputs: [],
      name: "LSP7InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0xa608fbb6 = keccak256('LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0xa608fbb6": {
      sig: "LSP7NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x26c247f4 = keccak256('LSP7NotifyTokenReceiverIsEOA(address)')
     */
    "0x26c247f4": {
      sig: "LSP7NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP7NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP7TokenOwnerCannotBeOperator()
     *
     * 0xdab75047 = keccak256('LSP7TokenOwnerCannotBeOperator()')
     */
    "0xdab75047": {
      sig: "LSP7TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP7TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8IdentifiableDigitalAsset: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8IdentifiableDigitalAssetInitAbstract: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8CappedSupply: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8CappedSupplyCannotMintOverCap()
     *
     * 0xe8ba2291 = keccak256('LSP8CappedSupplyCannotMintOverCap()')
     */
    "0xe8ba2291": {
      sig: "LSP8CappedSupplyCannotMintOverCap()",
      inputs: [],
      name: "LSP8CappedSupplyCannotMintOverCap",
      type: "error",
    },

    /**
     * error LSP8CappedSupplyRequired()
     *
     * 0x38d9fc30 = keccak256('LSP8CappedSupplyRequired()')
     */
    "0x38d9fc30": {
      sig: "LSP8CappedSupplyRequired()",
      inputs: [],
      name: "LSP8CappedSupplyRequired",
      type: "error",
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8CappedSupplyInitAbstract: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8CappedSupplyCannotMintOverCap()
     *
     * 0xe8ba2291 = keccak256('LSP8CappedSupplyCannotMintOverCap()')
     */
    "0xe8ba2291": {
      sig: "LSP8CappedSupplyCannotMintOverCap()",
      inputs: [],
      name: "LSP8CappedSupplyCannotMintOverCap",
      type: "error",
    },

    /**
     * error LSP8CappedSupplyRequired()
     *
     * 0x38d9fc30 = keccak256('LSP8CappedSupplyRequired()')
     */
    "0x38d9fc30": {
      sig: "LSP8CappedSupplyRequired()",
      inputs: [],
      name: "LSP8CappedSupplyRequired",
      type: "error",
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8CompatibleERC721: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8CompatibleERC721InitAbstract: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8CompatibleERC721Mintable: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenIdAlreadyMinted(
     *  bytes32 tokenId
     * )
     *
     * 0x34c7b511 = keccak256('LSP8TokenIdAlreadyMinted(bytes32)')
     */
    "0x34c7b511": {
      sig: "LSP8TokenIdAlreadyMinted(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8TokenIdAlreadyMinted",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has already been minted." }],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8CompatibleERC721MintableInit: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenIdAlreadyMinted(
     *  bytes32 tokenId
     * )
     *
     * 0x34c7b511 = keccak256('LSP8TokenIdAlreadyMinted(bytes32)')
     */
    "0x34c7b511": {
      sig: "LSP8TokenIdAlreadyMinted(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8TokenIdAlreadyMinted",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has already been minted." }],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8Mintable: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenIdAlreadyMinted(
     *  bytes32 tokenId
     * )
     *
     * 0x34c7b511 = keccak256('LSP8TokenIdAlreadyMinted(bytes32)')
     */
    "0x34c7b511": {
      sig: "LSP8TokenIdAlreadyMinted(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8TokenIdAlreadyMinted",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has already been minted." }],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP8MintableInit: {
    /**
     * error ERC725Y_DataKeysValuesEmptyArray()
     *
     * 0x97da5f95 = keccak256('ERC725Y_DataKeysValuesEmptyArray()')
     */
    "0x97da5f95": {
      sig: "ERC725Y_DataKeysValuesEmptyArray()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `setDataBatch` is an empty array",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP4TokenNameNotEditable()
     *
     * 0x85c169bd = keccak256('LSP4TokenNameNotEditable()')
     */
    "0x85c169bd": {
      sig: "LSP4TokenNameNotEditable()",
      inputs: [],
      name: "LSP4TokenNameNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenName` after the digital asset contract has been deployed.      The `LSP4TokenName` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP4TokenSymbolNotEditable()
     *
     * 0x76755b38 = keccak256('LSP4TokenSymbolNotEditable()')
     */
    "0x76755b38": {
      sig: "LSP4TokenSymbolNotEditable()",
      inputs: [],
      name: "LSP4TokenSymbolNotEditable",
      type: "error",
      userdoc: [
        {
          details:
            "Reverts when trying to edit the data key `LSP4TokenSymbol` after the digital asset contract has been deployed.      The `LSP4TokenSymbol` data key is located inside the ERC725Y Data key-value store of the digital asset contract.      It can be set only once inside the constructor/initializer when the digital asset contract is being deployed.",
        },
      ],
    },

    /**
     * error LSP8CannotSendToAddressZero()
     *
     * 0x24ecef4d = keccak256('LSP8CannotSendToAddressZero()')
     */
    "0x24ecef4d": {
      sig: "LSP8CannotSendToAddressZero()",
      inputs: [],
      name: "LSP8CannotSendToAddressZero",
      type: "error",
      userdoc: [
        { details: "reverts when trying to send token to the zero address." },
      ],
    },

    /**
     * error LSP8CannotSendToSelf()
     *
     * 0x5d67d6c1 = keccak256('LSP8CannotSendToSelf()')
     */
    "0x5d67d6c1": {
      sig: "LSP8CannotSendToSelf()",
      inputs: [],
      name: "LSP8CannotSendToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when specifying the same address for `from` and `to` in a token transfer.",
        },
      ],
    },

    /**
     * error LSP8CannotUseAddressZeroAsOperator()
     *
     * 0x9577b8b3 = keccak256('LSP8CannotUseAddressZeroAsOperator()')
     */
    "0x9577b8b3": {
      sig: "LSP8CannotUseAddressZeroAsOperator()",
      inputs: [],
      name: "LSP8CannotUseAddressZeroAsOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to set the zero address as an operator.",
        },
      ],
    },

    /**
     * error LSP8InvalidTransferBatch()
     *
     * 0x93a83119 = keccak256('LSP8InvalidTransferBatch()')
     */
    "0x93a83119": {
      sig: "LSP8InvalidTransferBatch()",
      inputs: [],
      name: "LSP8InvalidTransferBatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the parameters used for `transferBatch` have different lengths.",
        },
      ],
    },

    /**
     * error LSP8NonExistentTokenId(
     *  bytes32 tokenId
     * )
     *
     * 0xae8f9a36 = keccak256('LSP8NonExistentTokenId(bytes32)')
     */
    "0xae8f9a36": {
      sig: "LSP8NonExistentTokenId(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8NonExistentTokenId",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has not been minted." }],
    },

    /**
     * error LSP8NonExistingOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x4aa31a8c = keccak256('LSP8NonExistingOperator(address,bytes32)')
     */
    "0x4aa31a8c": {
      sig: "LSP8NonExistingOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8NonExistingOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is not an operator for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOperator(
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x1294d2a9 = keccak256('LSP8NotTokenOperator(bytes32,address)')
     */
    "0x1294d2a9": {
      sig: "LSP8NotTokenOperator(bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not an allowed operator for `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotTokenOwner(
     *  address tokenOwner,
     *  bytes32 tokenId,
     *  address caller
     * )
     *
     * 0x5b271ea2 = keccak256('LSP8NotTokenOwner(address,bytes32,address)')
     */
    "0x5b271ea2": {
      sig: "LSP8NotTokenOwner(address,bytes32,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "address", name: "caller", type: "address" },
      ],
      name: "LSP8NotTokenOwner",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `caller` is not the `tokenOwner` of the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverContractMissingLSP1Interface(
     *  address tokenReceiver
     * )
     *
     * 0x4349776d = keccak256('LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)')
     */
    "0x4349776d": {
      sig: "LSP8NotifyTokenReceiverContractMissingLSP1Interface(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverContractMissingLSP1Interface",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` does not implement LSP1 when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8NotifyTokenReceiverIsEOA(
     *  address tokenReceiver
     * )
     *
     * 0x03173137 = keccak256('LSP8NotifyTokenReceiverIsEOA(address)')
     */
    "0x03173137": {
      sig: "LSP8NotifyTokenReceiverIsEOA(address)",
      inputs: [
        { internalType: "address", name: "tokenReceiver", type: "address" },
      ],
      name: "LSP8NotifyTokenReceiverIsEOA",
      type: "error",
      userdoc: [
        {
          details:
            "reverts if the `tokenReceiver` is an EOA when minting or transferring tokens with `bool allowNonLSP1Recipient` set as `false`.",
        },
      ],
    },

    /**
     * error LSP8OperatorAlreadyAuthorized(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xa7626b68 = keccak256('LSP8OperatorAlreadyAuthorized(address,bytes32)')
     */
    "0xa7626b68": {
      sig: "LSP8OperatorAlreadyAuthorized(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "LSP8OperatorAlreadyAuthorized",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when `operator` is already authorized for the `tokenId`.",
        },
      ],
    },

    /**
     * error LSP8TokenIdAlreadyMinted(
     *  bytes32 tokenId
     * )
     *
     * 0x34c7b511 = keccak256('LSP8TokenIdAlreadyMinted(bytes32)')
     */
    "0x34c7b511": {
      sig: "LSP8TokenIdAlreadyMinted(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "LSP8TokenIdAlreadyMinted",
      type: "error",
      userdoc: [{ details: "reverts when `tokenId` has already been minted." }],
    },

    /**
     * error LSP8TokenOwnerCannotBeOperator()
     *
     * 0x89fdad62 = keccak256('LSP8TokenOwnerCannotBeOperator()')
     */
    "0x89fdad62": {
      sig: "LSP8TokenOwnerCannotBeOperator()",
      inputs: [],
      name: "LSP8TokenOwnerCannotBeOperator",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to authorize or revoke the token's owner as an operator.",
        },
      ],
    },
  },
  LSP9Vault: {
    /**
     * error CannotTransferOwnershipToSelf()
     *
     * 0x43b248cd = keccak256('CannotTransferOwnershipToSelf()')
     */
    "0x43b248cd": {
      sig: "CannotTransferOwnershipToSelf()",
      inputs: [],
      name: "CannotTransferOwnershipToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to transfer ownership to the address(this)",
        },
      ],
    },

    /**
     * error ERC725X_ContractDeploymentFailed()
     *
     * 0x0b07489b = keccak256('ERC725X_ContractDeploymentFailed()')
     */
    "0x0b07489b": {
      sig: "ERC725X_ContractDeploymentFailed()",
      inputs: [],
      name: "ERC725X_ContractDeploymentFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when contract deployment via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` failed. whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_CreateOperationsRequireEmptyRecipientAddress()
     *
     * 0x3041824a = keccak256('ERC725X_CreateOperationsRequireEmptyRecipientAddress()')
     */
    "0x3041824a": {
      sig: "ERC725X_CreateOperationsRequireEmptyRecipientAddress()",
      inputs: [],
      name: "ERC725X_CreateOperationsRequireEmptyRecipientAddress",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when passing a `to` address while deploying a contract va `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersEmptyArray()
     *
     * 0xe9ad2b5f = keccak256('ERC725X_ExecuteParametersEmptyArray()')
     */
    "0xe9ad2b5f": {
      sig: "ERC725X_ExecuteParametersEmptyArray()",
      inputs: [],
      name: "ERC725X_ExecuteParametersEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `executeBatch(uint256[],address[],uint256[],bytes[]) is an empty array",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersLengthMismatch()
     *
     * 0x3ff55f4d = keccak256('ERC725X_ExecuteParametersLengthMismatch()')
     */
    "0x3ff55f4d": {
      sig: "ERC725X_ExecuteParametersLengthMismatch()",
      inputs: [],
      name: "ERC725X_ExecuteParametersLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of operation, to addresses, value, and data.",
        },
      ],
    },

    /**
     * error ERC725X_InsufficientBalance(
     *  uint256 balance,
     *  uint256 value
     * )
     *
     * 0x0df9a8f8 = keccak256('ERC725X_InsufficientBalance(uint256,uint256)')
     */
    "0x0df9a8f8": {
      sig: "ERC725X_InsufficientBalance(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "ERC725X_InsufficientBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to send more native tokens `value` than available in current `balance`.",
          params: {
            balance: "the balance of the ERC725X contract.",
            value:
              "the amount of native tokens sent via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`.",
          },
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInStaticCall()
     *
     * 0x72f2bc6a = keccak256('ERC725X_MsgValueDisallowedInStaticCall()')
     */
    "0x72f2bc6a": {
      sig: "ERC725X_MsgValueDisallowedInStaticCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInStaticCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a staticcall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because sending native tokens is a state changing operation.",
        },
      ],
    },

    /**
     * error ERC725X_NoContractBytecodeProvided()
     *
     * 0xb81cd8d9 = keccak256('ERC725X_NoContractBytecodeProvided()')
     */
    "0xb81cd8d9": {
      sig: "ERC725X_NoContractBytecodeProvided()",
      inputs: [],
      name: "ERC725X_NoContractBytecodeProvided",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when no contract bytecode was provided as parameter when trying to deploy a contract via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`, whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_UnknownOperationType(
     *  uint256 operationTypeProvided
     * )
     *
     * 0x7583b3bc = keccak256('ERC725X_UnknownOperationType(uint256)')
     */
    "0x7583b3bc": {
      sig: "ERC725X_UnknownOperationType(uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "operationTypeProvided",
          type: "uint256",
        },
      ],
      name: "ERC725X_UnknownOperationType",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `operationTypeProvided` is none of the default operation types available. (CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4)",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP1DelegateNotAllowedToSetDataKey(
     *  bytes32 dataKey
     * )
     *
     * 0x199611f1 = keccak256('LSP1DelegateNotAllowedToSetDataKey(bytes32)')
     */
    "0x199611f1": {
      sig: "LSP1DelegateNotAllowedToSetDataKey(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "LSP1DelegateNotAllowedToSetDataKey",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the UniversalReceiverDelegates of the Vault sets LSP1/6/17 Data Keys",
          params: {
            dataKey:
              "The data key that the UniversalReceiverDelegate is not allowed to set",
          },
        },
      ],
    },

    /**
     * error NoExtensionFoundForFunctionSelector(
     *  bytes4 functionSelector
     * )
     *
     * 0xbb370b2b = keccak256('NoExtensionFoundForFunctionSelector(bytes4)')
     */
    "0xbb370b2b": {
      sig: "NoExtensionFoundForFunctionSelector(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "functionSelector", type: "bytes4" },
      ],
      name: "NoExtensionFoundForFunctionSelector",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is no extension for the function selector being called with",
        },
      ],
    },

    /**
     * error NotInRenounceOwnershipInterval(
     *  uint256 renounceOwnershipStart,
     *  uint256 renounceOwnershipEnd
     * )
     *
     * 0x8b9bf507 = keccak256('NotInRenounceOwnershipInterval(uint256,uint256)')
     */
    "0x8b9bf507": {
      sig: "NotInRenounceOwnershipInterval(uint256,uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "renounceOwnershipStart",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "renounceOwnershipEnd",
          type: "uint256",
        },
      ],
      name: "NotInRenounceOwnershipInterval",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to renounce ownership before the initial confirmation delay",
        },
      ],
    },
  },
  LSP9VaultInit: {
    /**
     * error CannotTransferOwnershipToSelf()
     *
     * 0x43b248cd = keccak256('CannotTransferOwnershipToSelf()')
     */
    "0x43b248cd": {
      sig: "CannotTransferOwnershipToSelf()",
      inputs: [],
      name: "CannotTransferOwnershipToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to transfer ownership to the address(this)",
        },
      ],
    },

    /**
     * error ERC725X_ContractDeploymentFailed()
     *
     * 0x0b07489b = keccak256('ERC725X_ContractDeploymentFailed()')
     */
    "0x0b07489b": {
      sig: "ERC725X_ContractDeploymentFailed()",
      inputs: [],
      name: "ERC725X_ContractDeploymentFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when contract deployment via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` failed. whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_CreateOperationsRequireEmptyRecipientAddress()
     *
     * 0x3041824a = keccak256('ERC725X_CreateOperationsRequireEmptyRecipientAddress()')
     */
    "0x3041824a": {
      sig: "ERC725X_CreateOperationsRequireEmptyRecipientAddress()",
      inputs: [],
      name: "ERC725X_CreateOperationsRequireEmptyRecipientAddress",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when passing a `to` address while deploying a contract va `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersEmptyArray()
     *
     * 0xe9ad2b5f = keccak256('ERC725X_ExecuteParametersEmptyArray()')
     */
    "0xe9ad2b5f": {
      sig: "ERC725X_ExecuteParametersEmptyArray()",
      inputs: [],
      name: "ERC725X_ExecuteParametersEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `executeBatch(uint256[],address[],uint256[],bytes[]) is an empty array",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersLengthMismatch()
     *
     * 0x3ff55f4d = keccak256('ERC725X_ExecuteParametersLengthMismatch()')
     */
    "0x3ff55f4d": {
      sig: "ERC725X_ExecuteParametersLengthMismatch()",
      inputs: [],
      name: "ERC725X_ExecuteParametersLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of operation, to addresses, value, and data.",
        },
      ],
    },

    /**
     * error ERC725X_InsufficientBalance(
     *  uint256 balance,
     *  uint256 value
     * )
     *
     * 0x0df9a8f8 = keccak256('ERC725X_InsufficientBalance(uint256,uint256)')
     */
    "0x0df9a8f8": {
      sig: "ERC725X_InsufficientBalance(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "ERC725X_InsufficientBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to send more native tokens `value` than available in current `balance`.",
          params: {
            balance: "the balance of the ERC725X contract.",
            value:
              "the amount of native tokens sent via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`.",
          },
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInStaticCall()
     *
     * 0x72f2bc6a = keccak256('ERC725X_MsgValueDisallowedInStaticCall()')
     */
    "0x72f2bc6a": {
      sig: "ERC725X_MsgValueDisallowedInStaticCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInStaticCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a staticcall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because sending native tokens is a state changing operation.",
        },
      ],
    },

    /**
     * error ERC725X_NoContractBytecodeProvided()
     *
     * 0xb81cd8d9 = keccak256('ERC725X_NoContractBytecodeProvided()')
     */
    "0xb81cd8d9": {
      sig: "ERC725X_NoContractBytecodeProvided()",
      inputs: [],
      name: "ERC725X_NoContractBytecodeProvided",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when no contract bytecode was provided as parameter when trying to deploy a contract via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`, whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_UnknownOperationType(
     *  uint256 operationTypeProvided
     * )
     *
     * 0x7583b3bc = keccak256('ERC725X_UnknownOperationType(uint256)')
     */
    "0x7583b3bc": {
      sig: "ERC725X_UnknownOperationType(uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "operationTypeProvided",
          type: "uint256",
        },
      ],
      name: "ERC725X_UnknownOperationType",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `operationTypeProvided` is none of the default operation types available. (CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4)",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error ERC725Y_MsgValueDisallowed()
     *
     * 0xf36ba737 = keccak256('ERC725Y_MsgValueDisallowed()')
     */
    "0xf36ba737": {
      sig: "ERC725Y_MsgValueDisallowed()",
      inputs: [],
      name: "ERC725Y_MsgValueDisallowed",
      type: "error",
      userdoc: [
        {
          details: "reverts when sending value to the `setData(..)` functions",
        },
      ],
    },

    /**
     * error LSP1DelegateNotAllowedToSetDataKey(
     *  bytes32 dataKey
     * )
     *
     * 0x199611f1 = keccak256('LSP1DelegateNotAllowedToSetDataKey(bytes32)')
     */
    "0x199611f1": {
      sig: "LSP1DelegateNotAllowedToSetDataKey(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "LSP1DelegateNotAllowedToSetDataKey",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the UniversalReceiverDelegates of the Vault sets LSP1/6/17 Data Keys",
          params: {
            dataKey:
              "The data key that the UniversalReceiverDelegate is not allowed to set",
          },
        },
      ],
    },

    /**
     * error NoExtensionFoundForFunctionSelector(
     *  bytes4 functionSelector
     * )
     *
     * 0xbb370b2b = keccak256('NoExtensionFoundForFunctionSelector(bytes4)')
     */
    "0xbb370b2b": {
      sig: "NoExtensionFoundForFunctionSelector(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "functionSelector", type: "bytes4" },
      ],
      name: "NoExtensionFoundForFunctionSelector",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is no extension for the function selector being called with",
        },
      ],
    },

    /**
     * error NotInRenounceOwnershipInterval(
     *  uint256 renounceOwnershipStart,
     *  uint256 renounceOwnershipEnd
     * )
     *
     * 0x8b9bf507 = keccak256('NotInRenounceOwnershipInterval(uint256,uint256)')
     */
    "0x8b9bf507": {
      sig: "NotInRenounceOwnershipInterval(uint256,uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "renounceOwnershipStart",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "renounceOwnershipEnd",
          type: "uint256",
        },
      ],
      name: "NotInRenounceOwnershipInterval",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to renounce ownership before the initial confirmation delay",
        },
      ],
    },
  },
  UniversalProfile: {
    /**
     * error CannotTransferOwnershipToSelf()
     *
     * 0x43b248cd = keccak256('CannotTransferOwnershipToSelf()')
     */
    "0x43b248cd": {
      sig: "CannotTransferOwnershipToSelf()",
      inputs: [],
      name: "CannotTransferOwnershipToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to transfer ownership to the address(this)",
        },
      ],
    },

    /**
     * error ERC725X_ContractDeploymentFailed()
     *
     * 0x0b07489b = keccak256('ERC725X_ContractDeploymentFailed()')
     */
    "0x0b07489b": {
      sig: "ERC725X_ContractDeploymentFailed()",
      inputs: [],
      name: "ERC725X_ContractDeploymentFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when contract deployment via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` failed. whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_CreateOperationsRequireEmptyRecipientAddress()
     *
     * 0x3041824a = keccak256('ERC725X_CreateOperationsRequireEmptyRecipientAddress()')
     */
    "0x3041824a": {
      sig: "ERC725X_CreateOperationsRequireEmptyRecipientAddress()",
      inputs: [],
      name: "ERC725X_CreateOperationsRequireEmptyRecipientAddress",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when passing a `to` address while deploying a contract va `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersEmptyArray()
     *
     * 0xe9ad2b5f = keccak256('ERC725X_ExecuteParametersEmptyArray()')
     */
    "0xe9ad2b5f": {
      sig: "ERC725X_ExecuteParametersEmptyArray()",
      inputs: [],
      name: "ERC725X_ExecuteParametersEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `executeBatch(uint256[],address[],uint256[],bytes[]) is an empty array",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersLengthMismatch()
     *
     * 0x3ff55f4d = keccak256('ERC725X_ExecuteParametersLengthMismatch()')
     */
    "0x3ff55f4d": {
      sig: "ERC725X_ExecuteParametersLengthMismatch()",
      inputs: [],
      name: "ERC725X_ExecuteParametersLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of operation, to addresses, value, and data.",
        },
      ],
    },

    /**
     * error ERC725X_InsufficientBalance(
     *  uint256 balance,
     *  uint256 value
     * )
     *
     * 0x0df9a8f8 = keccak256('ERC725X_InsufficientBalance(uint256,uint256)')
     */
    "0x0df9a8f8": {
      sig: "ERC725X_InsufficientBalance(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "ERC725X_InsufficientBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to send more native tokens `value` than available in current `balance`.",
          params: {
            balance: "the balance of the ERC725X contract.",
            value:
              "the amount of native tokens sent via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`.",
          },
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInDelegateCall()
     *
     * 0x5ac83135 = keccak256('ERC725X_MsgValueDisallowedInDelegateCall()')
     */
    "0x5ac83135": {
      sig: "ERC725X_MsgValueDisallowedInDelegateCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInDelegateCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a delegatecall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because msg.value is persisting.",
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInStaticCall()
     *
     * 0x72f2bc6a = keccak256('ERC725X_MsgValueDisallowedInStaticCall()')
     */
    "0x72f2bc6a": {
      sig: "ERC725X_MsgValueDisallowedInStaticCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInStaticCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a staticcall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because sending native tokens is a state changing operation.",
        },
      ],
    },

    /**
     * error ERC725X_NoContractBytecodeProvided()
     *
     * 0xb81cd8d9 = keccak256('ERC725X_NoContractBytecodeProvided()')
     */
    "0xb81cd8d9": {
      sig: "ERC725X_NoContractBytecodeProvided()",
      inputs: [],
      name: "ERC725X_NoContractBytecodeProvided",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when no contract bytecode was provided as parameter when trying to deploy a contract via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`, whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_UnknownOperationType(
     *  uint256 operationTypeProvided
     * )
     *
     * 0x7583b3bc = keccak256('ERC725X_UnknownOperationType(uint256)')
     */
    "0x7583b3bc": {
      sig: "ERC725X_UnknownOperationType(uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "operationTypeProvided",
          type: "uint256",
        },
      ],
      name: "ERC725X_UnknownOperationType",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `operationTypeProvided` is none of the default operation types available. (CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4)",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error LSP20CallingVerifierFailed(
     *  bool postCall
     * )
     *
     * 0x8c6a8ae3 = keccak256('LSP20CallingVerifierFailed(bool)')
     */
    "0x8c6a8ae3": {
      sig: "LSP20CallingVerifierFailed(bool)",
      inputs: [{ internalType: "bool", name: "postCall", type: "bool" }],
      name: "LSP20CallingVerifierFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the call to the owner fail with no revert reason",
          params: {
            postCall: "True if the execution call was done, False otherwise",
          },
        },
      ],
    },

    /**
     * error LSP20InvalidMagicValue(
     *  bool postCall,
     *  bytes returnedData
     * )
     *
     * 0xd088ec40 = keccak256('LSP20InvalidMagicValue(bool,bytes)')
     */
    "0xd088ec40": {
      sig: "LSP20InvalidMagicValue(bool,bytes)",
      inputs: [
        { internalType: "bool", name: "postCall", type: "bool" },
        { internalType: "bytes", name: "returnedData", type: "bytes" },
      ],
      name: "LSP20InvalidMagicValue",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the call to the owner does not return the magic value",
          params: {
            postCall: "The data returned by the call to the logic verifier",
          },
        },
      ],
    },

    /**
     * error NoExtensionFoundForFunctionSelector(
     *  bytes4 functionSelector
     * )
     *
     * 0xbb370b2b = keccak256('NoExtensionFoundForFunctionSelector(bytes4)')
     */
    "0xbb370b2b": {
      sig: "NoExtensionFoundForFunctionSelector(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "functionSelector", type: "bytes4" },
      ],
      name: "NoExtensionFoundForFunctionSelector",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is no extension for the function selector being called with",
        },
      ],
    },

    /**
     * error NotInRenounceOwnershipInterval(
     *  uint256 renounceOwnershipStart,
     *  uint256 renounceOwnershipEnd
     * )
     *
     * 0x8b9bf507 = keccak256('NotInRenounceOwnershipInterval(uint256,uint256)')
     */
    "0x8b9bf507": {
      sig: "NotInRenounceOwnershipInterval(uint256,uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "renounceOwnershipStart",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "renounceOwnershipEnd",
          type: "uint256",
        },
      ],
      name: "NotInRenounceOwnershipInterval",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to renounce ownership before the initial confirmation delay",
        },
      ],
    },
  },
  UniversalProfileInit: {
    /**
     * error CannotTransferOwnershipToSelf()
     *
     * 0x43b248cd = keccak256('CannotTransferOwnershipToSelf()')
     */
    "0x43b248cd": {
      sig: "CannotTransferOwnershipToSelf()",
      inputs: [],
      name: "CannotTransferOwnershipToSelf",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to transfer ownership to the address(this)",
        },
      ],
    },

    /**
     * error ERC725X_ContractDeploymentFailed()
     *
     * 0x0b07489b = keccak256('ERC725X_ContractDeploymentFailed()')
     */
    "0x0b07489b": {
      sig: "ERC725X_ContractDeploymentFailed()",
      inputs: [],
      name: "ERC725X_ContractDeploymentFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when contract deployment via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` failed. whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_CreateOperationsRequireEmptyRecipientAddress()
     *
     * 0x3041824a = keccak256('ERC725X_CreateOperationsRequireEmptyRecipientAddress()')
     */
    "0x3041824a": {
      sig: "ERC725X_CreateOperationsRequireEmptyRecipientAddress()",
      inputs: [],
      name: "ERC725X_CreateOperationsRequireEmptyRecipientAddress",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when passing a `to` address while deploying a contract va `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersEmptyArray()
     *
     * 0xe9ad2b5f = keccak256('ERC725X_ExecuteParametersEmptyArray()')
     */
    "0xe9ad2b5f": {
      sig: "ERC725X_ExecuteParametersEmptyArray()",
      inputs: [],
      name: "ERC725X_ExecuteParametersEmptyArray",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when one of the array parameter provided to `executeBatch(uint256[],address[],uint256[],bytes[]) is an empty array",
        },
      ],
    },

    /**
     * error ERC725X_ExecuteParametersLengthMismatch()
     *
     * 0x3ff55f4d = keccak256('ERC725X_ExecuteParametersLengthMismatch()')
     */
    "0x3ff55f4d": {
      sig: "ERC725X_ExecuteParametersLengthMismatch()",
      inputs: [],
      name: "ERC725X_ExecuteParametersLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of operation, to addresses, value, and data.",
        },
      ],
    },

    /**
     * error ERC725X_InsufficientBalance(
     *  uint256 balance,
     *  uint256 value
     * )
     *
     * 0x0df9a8f8 = keccak256('ERC725X_InsufficientBalance(uint256,uint256)')
     */
    "0x0df9a8f8": {
      sig: "ERC725X_InsufficientBalance(uint256,uint256)",
      inputs: [
        { internalType: "uint256", name: "balance", type: "uint256" },
        { internalType: "uint256", name: "value", type: "uint256" },
      ],
      name: "ERC725X_InsufficientBalance",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to send more native tokens `value` than available in current `balance`.",
          params: {
            balance: "the balance of the ERC725X contract.",
            value:
              "the amount of native tokens sent via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`.",
          },
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInDelegateCall()
     *
     * 0x5ac83135 = keccak256('ERC725X_MsgValueDisallowedInDelegateCall()')
     */
    "0x5ac83135": {
      sig: "ERC725X_MsgValueDisallowedInDelegateCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInDelegateCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a delegatecall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because msg.value is persisting.",
        },
      ],
    },

    /**
     * error ERC725X_MsgValueDisallowedInStaticCall()
     *
     * 0x72f2bc6a = keccak256('ERC725X_MsgValueDisallowedInStaticCall()')
     */
    "0x72f2bc6a": {
      sig: "ERC725X_MsgValueDisallowedInStaticCall()",
      inputs: [],
      name: "ERC725X_MsgValueDisallowedInStaticCall",
      type: "error",
      userdoc: [
        {
          details:
            "the `value` parameter (= sending native tokens) is not allowed when making a staticcall via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)` because sending native tokens is a state changing operation.",
        },
      ],
    },

    /**
     * error ERC725X_NoContractBytecodeProvided()
     *
     * 0xb81cd8d9 = keccak256('ERC725X_NoContractBytecodeProvided()')
     */
    "0xb81cd8d9": {
      sig: "ERC725X_NoContractBytecodeProvided()",
      inputs: [],
      name: "ERC725X_NoContractBytecodeProvided",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when no contract bytecode was provided as parameter when trying to deploy a contract via `ERC725X.execute(...)`/`ERC725X.executeBatch(...)`, whether using operation type 1 (CREATE) or 2 (CREATE2).",
        },
      ],
    },

    /**
     * error ERC725X_UnknownOperationType(
     *  uint256 operationTypeProvided
     * )
     *
     * 0x7583b3bc = keccak256('ERC725X_UnknownOperationType(uint256)')
     */
    "0x7583b3bc": {
      sig: "ERC725X_UnknownOperationType(uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "operationTypeProvided",
          type: "uint256",
        },
      ],
      name: "ERC725X_UnknownOperationType",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the `operationTypeProvided` is none of the default operation types available. (CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4)",
        },
      ],
    },

    /**
     * error ERC725Y_DataKeysValuesLengthMismatch()
     *
     * 0x3bcc8979 = keccak256('ERC725Y_DataKeysValuesLengthMismatch()')
     */
    "0x3bcc8979": {
      sig: "ERC725Y_DataKeysValuesLengthMismatch()",
      inputs: [],
      name: "ERC725Y_DataKeysValuesLengthMismatch",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is not the same number of elements in the lists of data keys and data values when calling setDataBatch.",
        },
      ],
    },

    /**
     * error LSP20CallingVerifierFailed(
     *  bool postCall
     * )
     *
     * 0x8c6a8ae3 = keccak256('LSP20CallingVerifierFailed(bool)')
     */
    "0x8c6a8ae3": {
      sig: "LSP20CallingVerifierFailed(bool)",
      inputs: [{ internalType: "bool", name: "postCall", type: "bool" }],
      name: "LSP20CallingVerifierFailed",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the call to the owner fail with no revert reason",
          params: {
            postCall: "True if the execution call was done, False otherwise",
          },
        },
      ],
    },

    /**
     * error LSP20InvalidMagicValue(
     *  bool postCall,
     *  bytes returnedData
     * )
     *
     * 0xd088ec40 = keccak256('LSP20InvalidMagicValue(bool,bytes)')
     */
    "0xd088ec40": {
      sig: "LSP20InvalidMagicValue(bool,bytes)",
      inputs: [
        { internalType: "bool", name: "postCall", type: "bool" },
        { internalType: "bytes", name: "returnedData", type: "bytes" },
      ],
      name: "LSP20InvalidMagicValue",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when the call to the owner does not return the magic value",
          params: {
            postCall: "The data returned by the call to the logic verifier",
          },
        },
      ],
    },

    /**
     * error NoExtensionFoundForFunctionSelector(
     *  bytes4 functionSelector
     * )
     *
     * 0xbb370b2b = keccak256('NoExtensionFoundForFunctionSelector(bytes4)')
     */
    "0xbb370b2b": {
      sig: "NoExtensionFoundForFunctionSelector(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "functionSelector", type: "bytes4" },
      ],
      name: "NoExtensionFoundForFunctionSelector",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when there is no extension for the function selector being called with",
        },
      ],
    },

    /**
     * error NotInRenounceOwnershipInterval(
     *  uint256 renounceOwnershipStart,
     *  uint256 renounceOwnershipEnd
     * )
     *
     * 0x8b9bf507 = keccak256('NotInRenounceOwnershipInterval(uint256,uint256)')
     */
    "0x8b9bf507": {
      sig: "NotInRenounceOwnershipInterval(uint256,uint256)",
      inputs: [
        {
          internalType: "uint256",
          name: "renounceOwnershipStart",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "renounceOwnershipEnd",
          type: "uint256",
        },
      ],
      name: "NotInRenounceOwnershipInterval",
      type: "error",
      userdoc: [
        {
          details:
            "reverts when trying to renounce ownership before the initial confirmation delay",
        },
      ],
    },
  },
};
export const EventSigHashes = {
  Create2Factory: {
    /**
     * event ContractCreated(
     *  address addr,
     *  bytes32 salt
     * )
     *
     * 0xc16bb3dbd36917c7aa3e76b988c2cd35e74bb230a02fef61e7376d8b4bfaea77 = keccak256('ContractCreated(address,bytes32)')
     */
    "0xc16bb3dbd36917c7aa3e76b988c2cd35e74bb230a02fef61e7376d8b4bfaea77": {
      sig: "ContractCreated(address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "addr",
          type: "address",
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "salt",
          type: "bytes32",
        },
      ],
      name: "ContractCreated",
      type: "event",
    },
  },
  LSP0ERC725Account: {
    /**
     * event ContractCreated(
     *  uint256 indexed operationType,
     *  address indexed contractAddress,
     *  uint256 indexed value,
     *  bytes32 salt
     * )
     *
     * 0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3 = keccak256('ContractCreated(uint256,address,uint256,bytes32)')
     */
    "0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3": {
      sig: "ContractCreated(uint256,address,uint256,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "contractAddress",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "salt",
          type: "bytes32",
        },
      ],
      name: "ContractCreated",
      type: "event",
      userdoc: { notice: "Emitted when deploying a contract" },
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Executed(
     *  uint256 indexed operationType,
     *  address indexed target,
     *  uint256 indexed value,
     *  bytes4 selector
     * )
     *
     * 0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e = keccak256('Executed(uint256,address,uint256,bytes4)')
     */
    "0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e": {
      sig: "Executed(uint256,address,uint256,bytes4)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "target",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes4",
          name: "selector",
          type: "bytes4",
        },
      ],
      name: "Executed",
      type: "event",
      userdoc: { notice: "Emitted when calling an address (EOA or contract)" },
    },

    /**
     * event OwnershipRenounced()
     *
     * 0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce = keccak256('OwnershipRenounced()')
     */
    "0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce": {
      sig: "OwnershipRenounced()",
      anonymous: false,
      inputs: [],
      name: "OwnershipRenounced",
      type: "event",
    },

    /**
     * event OwnershipTransferStarted(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700 = keccak256('OwnershipTransferStarted(address,address)')
     */
    "0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700": {
      sig: "OwnershipTransferStarted(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RenounceOwnershipStarted()
     *
     * 0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7 = keccak256('RenounceOwnershipStarted()')
     */
    "0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7": {
      sig: "RenounceOwnershipStarted()",
      anonymous: false,
      inputs: [],
      name: "RenounceOwnershipStarted",
      type: "event",
    },

    /**
     * event UniversalReceiver(
     *  address indexed from,
     *  uint256 indexed value,
     *  bytes32 indexed typeId,
     *  bytes receivedData,
     *  bytes returnedValue
     * )
     *
     * 0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2 = keccak256('UniversalReceiver(address,uint256,bytes32,bytes,bytes)')
     */
    "0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2": {
      sig: "UniversalReceiver(address,uint256,bytes32,bytes,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "typeId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "receivedData",
          type: "bytes",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "returnedValue",
          type: "bytes",
        },
      ],
      name: "UniversalReceiver",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the universalReceiver function is succesfully executed",
      },
    },

    /**
     * event ValueReceived(
     *  address indexed sender,
     *  uint256 indexed value
     * )
     *
     * 0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493 = keccak256('ValueReceived(address,uint256)')
     */
    "0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493": {
      sig: "ValueReceived(address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "ValueReceived",
      type: "event",
      userdoc: { notice: "Emitted when receiving native tokens" },
    },
  },
  LSP0ERC725AccountInit: {
    /**
     * event ContractCreated(
     *  uint256 indexed operationType,
     *  address indexed contractAddress,
     *  uint256 indexed value,
     *  bytes32 salt
     * )
     *
     * 0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3 = keccak256('ContractCreated(uint256,address,uint256,bytes32)')
     */
    "0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3": {
      sig: "ContractCreated(uint256,address,uint256,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "contractAddress",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "salt",
          type: "bytes32",
        },
      ],
      name: "ContractCreated",
      type: "event",
      userdoc: { notice: "Emitted when deploying a contract" },
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Executed(
     *  uint256 indexed operationType,
     *  address indexed target,
     *  uint256 indexed value,
     *  bytes4 selector
     * )
     *
     * 0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e = keccak256('Executed(uint256,address,uint256,bytes4)')
     */
    "0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e": {
      sig: "Executed(uint256,address,uint256,bytes4)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "target",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes4",
          name: "selector",
          type: "bytes4",
        },
      ],
      name: "Executed",
      type: "event",
      userdoc: { notice: "Emitted when calling an address (EOA or contract)" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipRenounced()
     *
     * 0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce = keccak256('OwnershipRenounced()')
     */
    "0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce": {
      sig: "OwnershipRenounced()",
      anonymous: false,
      inputs: [],
      name: "OwnershipRenounced",
      type: "event",
    },

    /**
     * event OwnershipTransferStarted(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700 = keccak256('OwnershipTransferStarted(address,address)')
     */
    "0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700": {
      sig: "OwnershipTransferStarted(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RenounceOwnershipStarted()
     *
     * 0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7 = keccak256('RenounceOwnershipStarted()')
     */
    "0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7": {
      sig: "RenounceOwnershipStarted()",
      anonymous: false,
      inputs: [],
      name: "RenounceOwnershipStarted",
      type: "event",
    },

    /**
     * event UniversalReceiver(
     *  address indexed from,
     *  uint256 indexed value,
     *  bytes32 indexed typeId,
     *  bytes receivedData,
     *  bytes returnedValue
     * )
     *
     * 0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2 = keccak256('UniversalReceiver(address,uint256,bytes32,bytes,bytes)')
     */
    "0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2": {
      sig: "UniversalReceiver(address,uint256,bytes32,bytes,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "typeId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "receivedData",
          type: "bytes",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "returnedValue",
          type: "bytes",
        },
      ],
      name: "UniversalReceiver",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the universalReceiver function is succesfully executed",
      },
    },

    /**
     * event ValueReceived(
     *  address indexed sender,
     *  uint256 indexed value
     * )
     *
     * 0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493 = keccak256('ValueReceived(address,uint256)')
     */
    "0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493": {
      sig: "ValueReceived(address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "ValueReceived",
      type: "event",
      userdoc: { notice: "Emitted when receiving native tokens" },
    },
  },
  LSP11BasicSocialRecovery: {
    /**
     * event GuardianAdded(
     *  address indexed newGuardian
     * )
     *
     * 0x038596bb31e2e7d3d9f184d4c98b310103f6d7f5830e5eec32bffe6f1728f969 = keccak256('GuardianAdded(address)')
     */
    "0x038596bb31e2e7d3d9f184d4c98b310103f6d7f5830e5eec32bffe6f1728f969": {
      sig: "GuardianAdded(address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "newGuardian",
          type: "address",
        },
      ],
      name: "GuardianAdded",
      type: "event",
      userdoc: { notice: "Emitted when setting a new guardian for the target" },
    },

    /**
     * event GuardianRemoved(
     *  address indexed removedGuardian
     * )
     *
     * 0xb8107d0c6b40be480ce3172ee66ba6d64b71f6b1685a851340036e6e2e3e3c52 = keccak256('GuardianRemoved(address)')
     */
    "0xb8107d0c6b40be480ce3172ee66ba6d64b71f6b1685a851340036e6e2e3e3c52": {
      sig: "GuardianRemoved(address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "removedGuardian",
          type: "address",
        },
      ],
      name: "GuardianRemoved",
      type: "event",
      userdoc: {
        notice: "Emitted when removing an existing guardian for the target",
      },
    },

    /**
     * event GuardiansThresholdChanged(
     *  uint256 indexed guardianThreshold
     * )
     *
     * 0x7146d20a2c7b7c75c203774c9f241b61698fac43a4a81ccd828f0d8162392790 = keccak256('GuardiansThresholdChanged(uint256)')
     */
    "0x7146d20a2c7b7c75c203774c9f241b61698fac43a4a81ccd828f0d8162392790": {
      sig: "GuardiansThresholdChanged(uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "guardianThreshold",
          type: "uint256",
        },
      ],
      name: "GuardiansThresholdChanged",
      type: "event",
      userdoc: { notice: "Emitted when changing the guardian threshold" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RecoveryProcessSuccessful(
     *  uint256 indexed recoveryCounter,
     *  address indexed newController,
     *  bytes32 indexed newSecretHash,
     *  address[] guardians
     * )
     *
     * 0xf4ff8803d6b43af46d48c200977209829c2f42f19f27eda1c89dbf26a28009cd = keccak256('RecoveryProcessSuccessful(uint256,address,bytes32,address[])')
     */
    "0xf4ff8803d6b43af46d48c200977209829c2f42f19f27eda1c89dbf26a28009cd": {
      sig: "RecoveryProcessSuccessful(uint256,address,bytes32,address[])",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "recoveryCounter",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newController",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "newSecretHash",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "address[]",
          name: "guardians",
          type: "address[]",
        },
      ],
      name: "RecoveryProcessSuccessful",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the recovery process is finished by the controller who reached the guardian threshold and submitted the string that produce the secretHash",
      },
    },

    /**
     * event SecretHashChanged(
     *  bytes32 indexed secretHash
     * )
     *
     * 0x2e8c5419a62207ade549fe0b66c1c85c16f5e1ed654815dee3a3f3ac41770df3 = keccak256('SecretHashChanged(bytes32)')
     */
    "0x2e8c5419a62207ade549fe0b66c1c85c16f5e1ed654815dee3a3f3ac41770df3": {
      sig: "SecretHashChanged(bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "secretHash",
          type: "bytes32",
        },
      ],
      name: "SecretHashChanged",
      type: "event",
      userdoc: { notice: "Emitted when changing the secret hash" },
    },

    /**
     * event SelectedNewController(
     *  uint256 indexed recoveryCounter,
     *  address indexed guardian,
     *  address indexed addressSelected
     * )
     *
     * 0xe43f3c1093c69ab76b2cf6246090acb2f8eab7f19ba9942dfc8b8ec446e3a3de = keccak256('SelectedNewController(uint256,address,address)')
     */
    "0xe43f3c1093c69ab76b2cf6246090acb2f8eab7f19ba9942dfc8b8ec446e3a3de": {
      sig: "SelectedNewController(uint256,address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "recoveryCounter",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "guardian",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "addressSelected",
          type: "address",
        },
      ],
      name: "SelectedNewController",
      type: "event",
      userdoc: {
        notice:
          "Emitted when a guardian select a new potentiel controller address for the target",
      },
    },
  },
  LSP11BasicSocialRecoveryInit: {
    /**
     * event GuardianAdded(
     *  address indexed newGuardian
     * )
     *
     * 0x038596bb31e2e7d3d9f184d4c98b310103f6d7f5830e5eec32bffe6f1728f969 = keccak256('GuardianAdded(address)')
     */
    "0x038596bb31e2e7d3d9f184d4c98b310103f6d7f5830e5eec32bffe6f1728f969": {
      sig: "GuardianAdded(address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "newGuardian",
          type: "address",
        },
      ],
      name: "GuardianAdded",
      type: "event",
      userdoc: { notice: "Emitted when setting a new guardian for the target" },
    },

    /**
     * event GuardianRemoved(
     *  address indexed removedGuardian
     * )
     *
     * 0xb8107d0c6b40be480ce3172ee66ba6d64b71f6b1685a851340036e6e2e3e3c52 = keccak256('GuardianRemoved(address)')
     */
    "0xb8107d0c6b40be480ce3172ee66ba6d64b71f6b1685a851340036e6e2e3e3c52": {
      sig: "GuardianRemoved(address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "removedGuardian",
          type: "address",
        },
      ],
      name: "GuardianRemoved",
      type: "event",
      userdoc: {
        notice: "Emitted when removing an existing guardian for the target",
      },
    },

    /**
     * event GuardiansThresholdChanged(
     *  uint256 indexed guardianThreshold
     * )
     *
     * 0x7146d20a2c7b7c75c203774c9f241b61698fac43a4a81ccd828f0d8162392790 = keccak256('GuardiansThresholdChanged(uint256)')
     */
    "0x7146d20a2c7b7c75c203774c9f241b61698fac43a4a81ccd828f0d8162392790": {
      sig: "GuardiansThresholdChanged(uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "guardianThreshold",
          type: "uint256",
        },
      ],
      name: "GuardiansThresholdChanged",
      type: "event",
      userdoc: { notice: "Emitted when changing the guardian threshold" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RecoveryProcessSuccessful(
     *  uint256 indexed recoveryCounter,
     *  address indexed newController,
     *  bytes32 indexed newSecretHash,
     *  address[] guardians
     * )
     *
     * 0xf4ff8803d6b43af46d48c200977209829c2f42f19f27eda1c89dbf26a28009cd = keccak256('RecoveryProcessSuccessful(uint256,address,bytes32,address[])')
     */
    "0xf4ff8803d6b43af46d48c200977209829c2f42f19f27eda1c89dbf26a28009cd": {
      sig: "RecoveryProcessSuccessful(uint256,address,bytes32,address[])",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "recoveryCounter",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newController",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "newSecretHash",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "address[]",
          name: "guardians",
          type: "address[]",
        },
      ],
      name: "RecoveryProcessSuccessful",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the recovery process is finished by the controller who reached the guardian threshold and submitted the string that produce the secretHash",
      },
    },

    /**
     * event SecretHashChanged(
     *  bytes32 indexed secretHash
     * )
     *
     * 0x2e8c5419a62207ade549fe0b66c1c85c16f5e1ed654815dee3a3f3ac41770df3 = keccak256('SecretHashChanged(bytes32)')
     */
    "0x2e8c5419a62207ade549fe0b66c1c85c16f5e1ed654815dee3a3f3ac41770df3": {
      sig: "SecretHashChanged(bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "secretHash",
          type: "bytes32",
        },
      ],
      name: "SecretHashChanged",
      type: "event",
      userdoc: { notice: "Emitted when changing the secret hash" },
    },

    /**
     * event SelectedNewController(
     *  uint256 indexed recoveryCounter,
     *  address indexed guardian,
     *  address indexed addressSelected
     * )
     *
     * 0xe43f3c1093c69ab76b2cf6246090acb2f8eab7f19ba9942dfc8b8ec446e3a3de = keccak256('SelectedNewController(uint256,address,address)')
     */
    "0xe43f3c1093c69ab76b2cf6246090acb2f8eab7f19ba9942dfc8b8ec446e3a3de": {
      sig: "SelectedNewController(uint256,address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "recoveryCounter",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "guardian",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "addressSelected",
          type: "address",
        },
      ],
      name: "SelectedNewController",
      type: "event",
      userdoc: {
        notice:
          "Emitted when a guardian select a new potentiel controller address for the target",
      },
    },
  },
  LSP16UniversalFactory: {
    /**
     * event ContractCreated(
     *  address indexed contractCreated,
     *  bytes32 indexed providedSalt,
     *  bytes32 generatedSalt,
     *  bool indexed initialized,
     *  bytes initializeCalldata
     * )
     *
     * 0x8872a323d65599f01bf90dc61c94b4e0cc8e2347d6af4122fccc3e112ee34a84 = keccak256('ContractCreated(address,bytes32,bytes32,bool,bytes)')
     */
    "0x8872a323d65599f01bf90dc61c94b4e0cc8e2347d6af4122fccc3e112ee34a84": {
      sig: "ContractCreated(address,bytes32,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "contractCreated",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "providedSalt",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "generatedSalt",
          type: "bytes32",
        },
        {
          indexed: true,
          internalType: "bool",
          name: "initialized",
          type: "bool",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "initializeCalldata",
          type: "bytes",
        },
      ],
      name: "ContractCreated",
      type: "event",
      devdoc: {
        details: "Emitted whenever a contract is created",
        params: {
          contractCreated: "The address of the contract created",
          generatedSalt:
            "The salt used by the `CREATE2` opcode for contract deployment",
          initializeCalldata:
            "The bytes provided as initializeCalldata (Empty string when `initialized` is set to false)",
          initialized:
            "The Boolean that specifies if the contract must be initialized or not",
          providedSalt:
            "The salt provided by the deployer, which will be used to generate the final salt that will be used by the `CREATE2` opcode for contract deployment",
        },
      },
    },
  },
  LSP1UniversalReceiverDelegateUP: {
    /**
     * event UniversalReceiver(
     *  address indexed from,
     *  uint256 indexed value,
     *  bytes32 indexed typeId,
     *  bytes receivedData,
     *  bytes returnedValue
     * )
     *
     * 0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2 = keccak256('UniversalReceiver(address,uint256,bytes32,bytes,bytes)')
     */
    "0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2": {
      sig: "UniversalReceiver(address,uint256,bytes32,bytes,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "typeId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "receivedData",
          type: "bytes",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "returnedValue",
          type: "bytes",
        },
      ],
      name: "UniversalReceiver",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the universalReceiver function is succesfully executed",
      },
    },
  },
  LSP1UniversalReceiverDelegateVault: {
    /**
     * event UniversalReceiver(
     *  address indexed from,
     *  uint256 indexed value,
     *  bytes32 indexed typeId,
     *  bytes receivedData,
     *  bytes returnedValue
     * )
     *
     * 0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2 = keccak256('UniversalReceiver(address,uint256,bytes32,bytes,bytes)')
     */
    "0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2": {
      sig: "UniversalReceiver(address,uint256,bytes32,bytes,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "typeId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "receivedData",
          type: "bytes",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "returnedValue",
          type: "bytes",
        },
      ],
      name: "UniversalReceiver",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the universalReceiver function is succesfully executed",
      },
    },
  },
  LSP4Compatibility: {
    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
  },
  LSP4DigitalAssetMetadata: {
    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
  },
  LSP4DigitalAssetMetadataInitAbstract: {
    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
  },
  LSP6KeyManager: {
    /**
     * event VerifiedCall(
     *  address indexed signer,
     *  uint256 indexed value,
     *  bytes4 indexed selector
     * )
     *
     * 0xa54458b75709e42f79700ffb6cfc57c7e224d8a77a52c457ee7ecb8e22636280 = keccak256('VerifiedCall(address,uint256,bytes4)')
     */
    "0xa54458b75709e42f79700ffb6cfc57c7e224d8a77a52c457ee7ecb8e22636280": {
      sig: "VerifiedCall(address,uint256,bytes4)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes4",
          name: "selector",
          type: "bytes4",
        },
      ],
      name: "VerifiedCall",
      type: "event",
    },
  },
  LSP6KeyManagerInit: {
    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event VerifiedCall(
     *  address indexed signer,
     *  uint256 indexed value,
     *  bytes4 indexed selector
     * )
     *
     * 0xa54458b75709e42f79700ffb6cfc57c7e224d8a77a52c457ee7ecb8e22636280 = keccak256('VerifiedCall(address,uint256,bytes4)')
     */
    "0xa54458b75709e42f79700ffb6cfc57c7e224d8a77a52c457ee7ecb8e22636280": {
      sig: "VerifiedCall(address,uint256,bytes4)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes4",
          name: "selector",
          type: "bytes4",
        },
      ],
      name: "VerifiedCall",
      type: "event",
    },
  },
  LSP7DigitalAsset: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP7DigitalAssetInitAbstract: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP7CappedSupply: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP7CappedSupplyInitAbstract: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP7CompatibleERC20: {
    /**
     * event Approval(
     *  address indexed owner,
     *  address indexed spender,
     *  uint256 value
     * )
     *
     * 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925 = keccak256('Approval(address,address,uint256)')
     */
    "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": {
      sig: "Approval(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC20 events.",
      },
    },

    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed from,
     *  address indexed to,
     *  uint256 value
     * )
     *
     * 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = keccak256('Transfer(address,address,uint256)')
     */
    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": {
      sig: "Transfer(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC20 events.",
      },
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP7CompatibleERC20InitAbstract: {
    /**
     * event Approval(
     *  address indexed owner,
     *  address indexed spender,
     *  uint256 value
     * )
     *
     * 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925 = keccak256('Approval(address,address,uint256)')
     */
    "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": {
      sig: "Approval(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC20 events.",
      },
    },

    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed from,
     *  address indexed to,
     *  uint256 value
     * )
     *
     * 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = keccak256('Transfer(address,address,uint256)')
     */
    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": {
      sig: "Transfer(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC20 events.",
      },
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP7CompatibleERC20Mintable: {
    /**
     * event Approval(
     *  address indexed owner,
     *  address indexed spender,
     *  uint256 value
     * )
     *
     * 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925 = keccak256('Approval(address,address,uint256)')
     */
    "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": {
      sig: "Approval(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC20 events.",
      },
    },

    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed from,
     *  address indexed to,
     *  uint256 value
     * )
     *
     * 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = keccak256('Transfer(address,address,uint256)')
     */
    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": {
      sig: "Transfer(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC20 events.",
      },
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP7CompatibleERC20MintableInit: {
    /**
     * event Approval(
     *  address indexed owner,
     *  address indexed spender,
     *  uint256 value
     * )
     *
     * 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925 = keccak256('Approval(address,address,uint256)')
     */
    "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": {
      sig: "Approval(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC20 events.",
      },
    },

    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed from,
     *  address indexed to,
     *  uint256 value
     * )
     *
     * 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = keccak256('Transfer(address,address,uint256)')
     */
    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": {
      sig: "Transfer(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC20 events.",
      },
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP7Mintable: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP7MintableInit: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  uint256 indexed amount
     * )
     *
     * 0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c = keccak256('AuthorizedOperator(address,address,uint256)')
     */
    "0xd66aff874162a96578e919097b6f6d153dfd89a5cec41bb331fdb0c4aec16e2c": {
      sig: "AuthorizedOperator(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner
     * )
     *
     * 0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1 = keccak256('RevokedOperator(address,address)')
     */
    "0x50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa1": {
      sig: "RevokedOperator(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed operator,
     *  address indexed from,
     *  address indexed to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6 = keccak256('Transfer(address,address,address,uint256,bool,bytes)')
     */
    "0x3997e418d2cef0b3b0e907b1e39605c3f7d32dbd061e82ea5b4a770d46a160a6": {
      sig: "Transfer(address,address,address,uint256,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8IdentifiableDigitalAsset: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8IdentifiableDigitalAssetInitAbstract: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8CappedSupply: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8CappedSupplyInitAbstract: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8CompatibleERC721: {
    /**
     * event Approval(
     *  address indexed owner,
     *  address indexed approved,
     *  uint256 indexed tokenId
     * )
     *
     * 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925 = keccak256('Approval(address,address,uint256)')
     */
    "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": {
      sig: "Approval(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC721 events.",
      },
    },

    /**
     * event ApprovalForAll(
     *  address indexed owner,
     *  address indexed operator,
     *  bool approved
     * )
     *
     * 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31 = keccak256('ApprovalForAll(address,address,bool)')
     */
    "0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31": {
      sig: "ApprovalForAll(address,address,bool)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "ApprovalForAll",
      type: "event",
    },

    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed from,
     *  address indexed to,
     *  uint256 indexed tokenId
     * )
     *
     * 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = keccak256('Transfer(address,address,uint256)')
     */
    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": {
      sig: "Transfer(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC721 events.",
      },
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8CompatibleERC721InitAbstract: {
    /**
     * event Approval(
     *  address indexed owner,
     *  address indexed approved,
     *  uint256 indexed tokenId
     * )
     *
     * 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925 = keccak256('Approval(address,address,uint256)')
     */
    "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": {
      sig: "Approval(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC721 events.",
      },
    },

    /**
     * event ApprovalForAll(
     *  address indexed owner,
     *  address indexed operator,
     *  bool approved
     * )
     *
     * 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31 = keccak256('ApprovalForAll(address,address,bool)')
     */
    "0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31": {
      sig: "ApprovalForAll(address,address,bool)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "ApprovalForAll",
      type: "event",
    },

    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed from,
     *  address indexed to,
     *  uint256 indexed tokenId
     * )
     *
     * 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = keccak256('Transfer(address,address,uint256)')
     */
    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": {
      sig: "Transfer(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC721 events.",
      },
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8CompatibleERC721Mintable: {
    /**
     * event Approval(
     *  address indexed owner,
     *  address indexed approved,
     *  uint256 indexed tokenId
     * )
     *
     * 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925 = keccak256('Approval(address,address,uint256)')
     */
    "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": {
      sig: "Approval(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC721 events.",
      },
    },

    /**
     * event ApprovalForAll(
     *  address indexed owner,
     *  address indexed operator,
     *  bool approved
     * )
     *
     * 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31 = keccak256('ApprovalForAll(address,address,bool)')
     */
    "0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31": {
      sig: "ApprovalForAll(address,address,bool)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "ApprovalForAll",
      type: "event",
    },

    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed from,
     *  address indexed to,
     *  uint256 indexed tokenId
     * )
     *
     * 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = keccak256('Transfer(address,address,uint256)')
     */
    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": {
      sig: "Transfer(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC721 events.",
      },
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8CompatibleERC721MintableInit: {
    /**
     * event Approval(
     *  address indexed owner,
     *  address indexed approved,
     *  uint256 indexed tokenId
     * )
     *
     * 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925 = keccak256('Approval(address,address,uint256)')
     */
    "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": {
      sig: "Approval(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC721 events.",
      },
    },

    /**
     * event ApprovalForAll(
     *  address indexed owner,
     *  address indexed operator,
     *  bool approved
     * )
     *
     * 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31 = keccak256('ApprovalForAll(address,address,bool)')
     */
    "0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31": {
      sig: "ApprovalForAll(address,address,bool)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "ApprovalForAll",
      type: "event",
    },

    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address indexed from,
     *  address indexed to,
     *  uint256 indexed tokenId
     * )
     *
     * 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = keccak256('Transfer(address,address,uint256)')
     */
    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": {
      sig: "Transfer(address,address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
      userdoc: {
        notice: "To provide compatibility with indexing ERC721 events.",
      },
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8Mintable: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP8MintableInit: {
    /**
     * event AuthorizedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988 = keccak256('AuthorizedOperator(address,address,bytes32)')
     */
    "0x34b797fc5a526f7bf1d2b5de25f6564fd85ae364e3ee939aee7c1ac27871a988": {
      sig: "AuthorizedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "AuthorizedOperator",
      type: "event",
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RevokedOperator(
     *  address indexed operator,
     *  address indexed tokenOwner,
     *  bytes32 indexed tokenId
     * )
     *
     * 0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5 = keccak256('RevokedOperator(address,address,bytes32)')
     */
    "0x17d5389f6ab6adb2647dfa0aa365c323d37adacc30b33a65310b6158ce1373d5": {
      sig: "RevokedOperator(address,address,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
      ],
      name: "RevokedOperator",
      type: "event",
    },

    /**
     * event Transfer(
     *  address operator,
     *  address indexed from,
     *  address indexed to,
     *  bytes32 indexed tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf = keccak256('Transfer(address,address,address,bytes32,bool,bytes)')
     */
    "0xb333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf": {
      sig: "Transfer(address,address,address,bytes32,bool,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        { indexed: true, internalType: "address", name: "to", type: "address" },
        {
          indexed: true,
          internalType: "bytes32",
          name: "tokenId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bool",
          name: "allowNonLSP1Recipient",
          type: "bool",
        },
        { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "Transfer",
      type: "event",
    },
  },
  LSP9Vault: {
    /**
     * event ContractCreated(
     *  uint256 indexed operationType,
     *  address indexed contractAddress,
     *  uint256 indexed value,
     *  bytes32 salt
     * )
     *
     * 0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3 = keccak256('ContractCreated(uint256,address,uint256,bytes32)')
     */
    "0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3": {
      sig: "ContractCreated(uint256,address,uint256,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "contractAddress",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "salt",
          type: "bytes32",
        },
      ],
      name: "ContractCreated",
      type: "event",
      userdoc: { notice: "Emitted when deploying a contract" },
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Executed(
     *  uint256 indexed operationType,
     *  address indexed target,
     *  uint256 indexed value,
     *  bytes4 selector
     * )
     *
     * 0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e = keccak256('Executed(uint256,address,uint256,bytes4)')
     */
    "0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e": {
      sig: "Executed(uint256,address,uint256,bytes4)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "target",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes4",
          name: "selector",
          type: "bytes4",
        },
      ],
      name: "Executed",
      type: "event",
      userdoc: { notice: "Emitted when calling an address (EOA or contract)" },
    },

    /**
     * event OwnershipRenounced()
     *
     * 0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce = keccak256('OwnershipRenounced()')
     */
    "0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce": {
      sig: "OwnershipRenounced()",
      anonymous: false,
      inputs: [],
      name: "OwnershipRenounced",
      type: "event",
    },

    /**
     * event OwnershipTransferStarted(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700 = keccak256('OwnershipTransferStarted(address,address)')
     */
    "0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700": {
      sig: "OwnershipTransferStarted(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RenounceOwnershipStarted()
     *
     * 0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7 = keccak256('RenounceOwnershipStarted()')
     */
    "0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7": {
      sig: "RenounceOwnershipStarted()",
      anonymous: false,
      inputs: [],
      name: "RenounceOwnershipStarted",
      type: "event",
    },

    /**
     * event UniversalReceiver(
     *  address indexed from,
     *  uint256 indexed value,
     *  bytes32 indexed typeId,
     *  bytes receivedData,
     *  bytes returnedValue
     * )
     *
     * 0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2 = keccak256('UniversalReceiver(address,uint256,bytes32,bytes,bytes)')
     */
    "0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2": {
      sig: "UniversalReceiver(address,uint256,bytes32,bytes,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "typeId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "receivedData",
          type: "bytes",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "returnedValue",
          type: "bytes",
        },
      ],
      name: "UniversalReceiver",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the universalReceiver function is succesfully executed",
      },
    },

    /**
     * event ValueReceived(
     *  address indexed sender,
     *  uint256 indexed value
     * )
     *
     * 0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493 = keccak256('ValueReceived(address,uint256)')
     */
    "0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493": {
      sig: "ValueReceived(address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "ValueReceived",
      type: "event",
      userdoc: { notice: "Emitted when receiving native tokens" },
    },
  },
  LSP9VaultInit: {
    /**
     * event ContractCreated(
     *  uint256 indexed operationType,
     *  address indexed contractAddress,
     *  uint256 indexed value,
     *  bytes32 salt
     * )
     *
     * 0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3 = keccak256('ContractCreated(uint256,address,uint256,bytes32)')
     */
    "0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3": {
      sig: "ContractCreated(uint256,address,uint256,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "contractAddress",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "salt",
          type: "bytes32",
        },
      ],
      name: "ContractCreated",
      type: "event",
      userdoc: { notice: "Emitted when deploying a contract" },
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Executed(
     *  uint256 indexed operationType,
     *  address indexed target,
     *  uint256 indexed value,
     *  bytes4 selector
     * )
     *
     * 0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e = keccak256('Executed(uint256,address,uint256,bytes4)')
     */
    "0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e": {
      sig: "Executed(uint256,address,uint256,bytes4)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "target",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes4",
          name: "selector",
          type: "bytes4",
        },
      ],
      name: "Executed",
      type: "event",
      userdoc: { notice: "Emitted when calling an address (EOA or contract)" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipRenounced()
     *
     * 0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce = keccak256('OwnershipRenounced()')
     */
    "0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce": {
      sig: "OwnershipRenounced()",
      anonymous: false,
      inputs: [],
      name: "OwnershipRenounced",
      type: "event",
    },

    /**
     * event OwnershipTransferStarted(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700 = keccak256('OwnershipTransferStarted(address,address)')
     */
    "0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700": {
      sig: "OwnershipTransferStarted(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RenounceOwnershipStarted()
     *
     * 0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7 = keccak256('RenounceOwnershipStarted()')
     */
    "0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7": {
      sig: "RenounceOwnershipStarted()",
      anonymous: false,
      inputs: [],
      name: "RenounceOwnershipStarted",
      type: "event",
    },

    /**
     * event UniversalReceiver(
     *  address indexed from,
     *  uint256 indexed value,
     *  bytes32 indexed typeId,
     *  bytes receivedData,
     *  bytes returnedValue
     * )
     *
     * 0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2 = keccak256('UniversalReceiver(address,uint256,bytes32,bytes,bytes)')
     */
    "0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2": {
      sig: "UniversalReceiver(address,uint256,bytes32,bytes,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "typeId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "receivedData",
          type: "bytes",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "returnedValue",
          type: "bytes",
        },
      ],
      name: "UniversalReceiver",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the universalReceiver function is succesfully executed",
      },
    },

    /**
     * event ValueReceived(
     *  address indexed sender,
     *  uint256 indexed value
     * )
     *
     * 0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493 = keccak256('ValueReceived(address,uint256)')
     */
    "0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493": {
      sig: "ValueReceived(address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "ValueReceived",
      type: "event",
      userdoc: { notice: "Emitted when receiving native tokens" },
    },
  },
  UniversalProfile: {
    /**
     * event ContractCreated(
     *  uint256 indexed operationType,
     *  address indexed contractAddress,
     *  uint256 indexed value,
     *  bytes32 salt
     * )
     *
     * 0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3 = keccak256('ContractCreated(uint256,address,uint256,bytes32)')
     */
    "0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3": {
      sig: "ContractCreated(uint256,address,uint256,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "contractAddress",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "salt",
          type: "bytes32",
        },
      ],
      name: "ContractCreated",
      type: "event",
      userdoc: { notice: "Emitted when deploying a contract" },
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Executed(
     *  uint256 indexed operationType,
     *  address indexed target,
     *  uint256 indexed value,
     *  bytes4 selector
     * )
     *
     * 0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e = keccak256('Executed(uint256,address,uint256,bytes4)')
     */
    "0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e": {
      sig: "Executed(uint256,address,uint256,bytes4)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "target",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes4",
          name: "selector",
          type: "bytes4",
        },
      ],
      name: "Executed",
      type: "event",
      userdoc: { notice: "Emitted when calling an address (EOA or contract)" },
    },

    /**
     * event OwnershipRenounced()
     *
     * 0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce = keccak256('OwnershipRenounced()')
     */
    "0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce": {
      sig: "OwnershipRenounced()",
      anonymous: false,
      inputs: [],
      name: "OwnershipRenounced",
      type: "event",
    },

    /**
     * event OwnershipTransferStarted(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700 = keccak256('OwnershipTransferStarted(address,address)')
     */
    "0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700": {
      sig: "OwnershipTransferStarted(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RenounceOwnershipStarted()
     *
     * 0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7 = keccak256('RenounceOwnershipStarted()')
     */
    "0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7": {
      sig: "RenounceOwnershipStarted()",
      anonymous: false,
      inputs: [],
      name: "RenounceOwnershipStarted",
      type: "event",
    },

    /**
     * event UniversalReceiver(
     *  address indexed from,
     *  uint256 indexed value,
     *  bytes32 indexed typeId,
     *  bytes receivedData,
     *  bytes returnedValue
     * )
     *
     * 0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2 = keccak256('UniversalReceiver(address,uint256,bytes32,bytes,bytes)')
     */
    "0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2": {
      sig: "UniversalReceiver(address,uint256,bytes32,bytes,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "typeId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "receivedData",
          type: "bytes",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "returnedValue",
          type: "bytes",
        },
      ],
      name: "UniversalReceiver",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the universalReceiver function is succesfully executed",
      },
    },

    /**
     * event ValueReceived(
     *  address indexed sender,
     *  uint256 indexed value
     * )
     *
     * 0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493 = keccak256('ValueReceived(address,uint256)')
     */
    "0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493": {
      sig: "ValueReceived(address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "ValueReceived",
      type: "event",
      userdoc: { notice: "Emitted when receiving native tokens" },
    },
  },
  UniversalProfileInit: {
    /**
     * event ContractCreated(
     *  uint256 indexed operationType,
     *  address indexed contractAddress,
     *  uint256 indexed value,
     *  bytes32 salt
     * )
     *
     * 0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3 = keccak256('ContractCreated(uint256,address,uint256,bytes32)')
     */
    "0xa1fb700aaee2ae4a2ff6f91ce7eba292f89c2f5488b8ec4c5c5c8150692595c3": {
      sig: "ContractCreated(uint256,address,uint256,bytes32)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "contractAddress",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "salt",
          type: "bytes32",
        },
      ],
      name: "ContractCreated",
      type: "event",
      userdoc: { notice: "Emitted when deploying a contract" },
    },

    /**
     * event DataChanged(
     *  bytes32 indexed dataKey,
     *  bytes dataValue
     * )
     *
     * 0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2 = keccak256('DataChanged(bytes32,bytes)')
     */
    "0xece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2": {
      sig: "DataChanged(bytes32,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "dataKey",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "dataValue",
          type: "bytes",
        },
      ],
      name: "DataChanged",
      type: "event",
      userdoc: { notice: "Emitted when data at a key is changed" },
    },

    /**
     * event Executed(
     *  uint256 indexed operationType,
     *  address indexed target,
     *  uint256 indexed value,
     *  bytes4 selector
     * )
     *
     * 0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e = keccak256('Executed(uint256,address,uint256,bytes4)')
     */
    "0x4810874456b8e6487bd861375cf6abd8e1c8bb5858c8ce36a86a04dabfac199e": {
      sig: "Executed(uint256,address,uint256,bytes4)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "operationType",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "address",
          name: "target",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: false,
          internalType: "bytes4",
          name: "selector",
          type: "bytes4",
        },
      ],
      name: "Executed",
      type: "event",
      userdoc: { notice: "Emitted when calling an address (EOA or contract)" },
    },

    /**
     * event Initialized(
     *  uint8 version
     * )
     *
     * 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498 = keccak256('Initialized(uint8)')
     */
    "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498": {
      sig: "Initialized(uint8)",
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8",
        },
      ],
      name: "Initialized",
      type: "event",
    },

    /**
     * event OwnershipRenounced()
     *
     * 0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce = keccak256('OwnershipRenounced()')
     */
    "0xd1f66c3d2bc1993a86be5e3d33709d98f0442381befcedd29f578b9b2506b1ce": {
      sig: "OwnershipRenounced()",
      anonymous: false,
      inputs: [],
      name: "OwnershipRenounced",
      type: "event",
    },

    /**
     * event OwnershipTransferStarted(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700 = keccak256('OwnershipTransferStarted(address,address)')
     */
    "0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700": {
      sig: "OwnershipTransferStarted(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferStarted",
      type: "event",
    },

    /**
     * event OwnershipTransferred(
     *  address indexed previousOwner,
     *  address indexed newOwner
     * )
     *
     * 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0 = keccak256('OwnershipTransferred(address,address)')
     */
    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0": {
      sig: "OwnershipTransferred(address,address)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },

    /**
     * event RenounceOwnershipStarted()
     *
     * 0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7 = keccak256('RenounceOwnershipStarted()')
     */
    "0x81b7f830f1f0084db6497c486cbe6974c86488dcc4e3738eab94ab6d6b1653e7": {
      sig: "RenounceOwnershipStarted()",
      anonymous: false,
      inputs: [],
      name: "RenounceOwnershipStarted",
      type: "event",
    },

    /**
     * event UniversalReceiver(
     *  address indexed from,
     *  uint256 indexed value,
     *  bytes32 indexed typeId,
     *  bytes receivedData,
     *  bytes returnedValue
     * )
     *
     * 0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2 = keccak256('UniversalReceiver(address,uint256,bytes32,bytes,bytes)')
     */
    "0x9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2": {
      sig: "UniversalReceiver(address,uint256,bytes32,bytes,bytes)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "typeId",
          type: "bytes32",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "receivedData",
          type: "bytes",
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "returnedValue",
          type: "bytes",
        },
      ],
      name: "UniversalReceiver",
      type: "event",
      userdoc: {
        notice:
          "Emitted when the universalReceiver function is succesfully executed",
      },
    },

    /**
     * event ValueReceived(
     *  address indexed sender,
     *  uint256 indexed value
     * )
     *
     * 0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493 = keccak256('ValueReceived(address,uint256)')
     */
    "0x7e71433ddf847725166244795048ecf3e3f9f35628254ecbf736056664233493": {
      sig: "ValueReceived(address,uint256)",
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "ValueReceived",
      type: "event",
      userdoc: { notice: "Emitted when receiving native tokens" },
    },
  },
};
export const FunctionSelectors = {
  Create2Factory: {
    /**
     * function computeAddress(
     *  bytes32 salt,
     *  bytes32 bytecodeHash
     * )
     *
     * 0x481286e6 = keccak256('computeAddress(bytes32,bytes32)')
     */
    "0x481286e6": {
      sig: "computeAddress(bytes32,bytes32)",
      inputs: [
        { internalType: "bytes32", name: "salt", type: "bytes32" },
        { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" },
      ],
      name: "computeAddress",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the address where a contract will be stored if deployed via {deploy}. Any change in the `bytecodeHash` or `salt` will result in a new destination address.",
      },
    },

    /**
     * function computeAddress(
     *  bytes32 salt,
     *  bytes32 bytecodeHash,
     *  address deployer
     * )
     *
     * 0x78065306 = keccak256('computeAddress(bytes32,bytes32,address)')
     */
    "0x78065306": {
      sig: "computeAddress(bytes32,bytes32,address)",
      inputs: [
        { internalType: "bytes32", name: "salt", type: "bytes32" },
        { internalType: "bytes32", name: "bytecodeHash", type: "bytes32" },
        { internalType: "address", name: "deployer", type: "address" },
      ],
      name: "computeAddress",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "pure",
      type: "function",
      devdoc: {
        details:
          "Returns the address where a contract will be stored if deployed via {deploy} from a contract located at `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.",
      },
    },

    /**
     * function deploy(
     *  bytes32 salt,
     *  bytes bytecode
     * )
     *
     * 0xcdcb760a = keccak256('deploy(bytes32,bytes)')
     */
    "0xcdcb760a": {
      sig: "deploy(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "salt", type: "bytes32" },
        { internalType: "bytes", name: "bytecode", type: "bytes" },
      ],
      name: "deploy",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Deploys a contract using `CREATE2`. The address where the contract will be deployed can be known in advance via {computeAddress}. The bytecode for a contract can be obtained from Solidity with `type(contractName).creationCode`. Requirements: - `bytecode` must not be empty. - `salt` must have not been used for `bytecode` already.",
      },
    },
  },
  LSP0ERC725Account: {
    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()
     *
     * 0xead3fbdf = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()')
     */
    "0xead3fbdf": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()
     *
     * 0x01bfba61 = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()')
     */
    "0x01bfba61": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function acceptOwnership()
     *
     * 0x79ba5097 = keccak256('acceptOwnership()')
     */
    "0x79ba5097": {
      sig: "acceptOwnership()",
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfer ownership of the contract from the current `owner()` to the `pendingOwner()`. Once this function is called: - the current `owner()` will loose access to the functions restricted to the `owner()` only. - the `pendingOwner()` will gain access to the functions restricted to the `owner()` only. Requirements: - MUST be called by the pendingOwner. - When notifying the previous owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferred_SenderNotification'). - When notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferred_RecipientNotification').",
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.",
      },
    },

    /**
     * function batchCalls(
     *  bytes[] data
     * )
     *
     * 0x6963d438 = keccak256('batchCalls(bytes[])')
     */
    "0x6963d438": {
      sig: "batchCalls(bytes[])",
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "batchCalls",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Allows a caller to batch different function calls in one call. Perform a delegatecall on self, to call different functions with preserving the context It is not possible to send value along the functions call due to the use of delegatecall.",
        params: {
          data: "An array of ABI encoded function calls to be called on the contract.",
        },
        returns: {
          results: "An array of values returned by the executed functions.",
        },
      },
    },

    /**
     * function execute(
     *  uint256 operationType,
     *  address target,
     *  uint256 value,
     *  bytes data
     * )
     *
     * 0x44c028fe = keccak256('execute(uint256,address,uint256,bytes)')
     */
    "0x44c028fe": {
      sig: "execute(uint256,address,uint256,bytes)",
      inputs: [
        { internalType: "uint256", name: "operationType", type: "uint256" },
        { internalType: "address", name: "target", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "execute",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Executes any call on other addresses.",
        params: {
          data: "The call data to execute on `target`, or the bytecode of the contract to deploy Requirements: - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully. - if the operation type is {STATICCALL} or {DELEGATECALL}, `value` SHOULD be 0. - `target` SHOULD be address(0) when deploying a contract. - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4 Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 Emits a {ValueReceived} event when receiving native tokens.",
          operationType:
            "The operation to execute: CALL = 0 CREATE = 1 CREATE2 = 2 STATICCALL = 3 DELEGATECALL = 4",
          target:
            "The address (smart contract/EOA) to interact with, `target` will be unused if a contract is created (operation 1 and 2)",
          value: "The amount of native tokens to transfer (in Wei).",
        },
      },
    },

    /**
     * function executeBatch(
     *  uint256[] operationsType,
     *  address[] targets,
     *  uint256[] values,
     *  bytes[] datas
     * )
     *
     * 0x31858452 = keccak256('executeBatch(uint256[],address[],uint256[],bytes[])')
     */
    "0x31858452": {
      sig: "executeBatch(uint256[],address[],uint256[],bytes[])",
      inputs: [
        {
          internalType: "uint256[]",
          name: "operationsType",
          type: "uint256[]",
        },
        { internalType: "address[]", name: "targets", type: "address[]" },
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "datas", type: "bytes[]" },
      ],
      name: "executeBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Generic batch executor function that executes any call on other addresses",
        params: {
          datas:
            "The list of call data to execute on `targets`, or the creation bytecode of the contracts to deploy Requirements: - The length of the parameters provided MUST be equal - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully. - if the operation type is {STATICCALL} or {DELEGATECALL}, `value` SHOULD be 0. - `target` SHOULD be address(0) when deploying a contract. - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4 (each iteration) Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 (each iteration) Emits a {ValueReceived} event when receiving native tokens.",
          operationsType:
            "The list of operations type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",
          targets:
            "The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",
          values: "The list of native token amounts to transfer (in Wei)",
        },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function isValidSignature(
     *  bytes32 dataHash,
     *  bytes signature
     * )
     *
     * 0x1626ba7e = keccak256('isValidSignature(bytes32,bytes)')
     */
    "0x1626ba7e": {
      sig: "isValidSignature(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataHash", type: "bytes32" },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "isValidSignature",
      outputs: [{ internalType: "bytes4", name: "magicValue", type: "bytes4" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Handles two cases: - If the owner is an EOA, recovers an address from the hash and the signature provided:      - Returns the magicValue if the address recovered is the same as the owner, indicating        that it was a valid signature.      - If the address is different, it returns the fail value indicating that the signature is not valid. - If the owner is a smart contract, it forwards the call of {isValidSignature} to the owner contract:      - If the contract fails or returns the fail value, the {isValidSignature} on the account returns the        fail value, indicating that the signature is not valid.      - If the {isValidSignature} on the owner returned the magicValue, the {isValidSignature} on the account        returns the magicValue, indicating that it's a valid signature.",
        params: {
          dataHash: "The hash of the data to be validated.",
          signature:
            "A signature that can validate the previous parameter (Hash).",
        },
        returns: {
          magicValue:
            "A bytes4 value that indicates if the signature is valid or not.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of EIP-1271 by validating signatures of smart contracts according to their own logic.",
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function pendingOwner()
     *
     * 0xe30c3978 = keccak256('pendingOwner()')
     */
    "0xe30c3978": {
      sig: "pendingOwner()",
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "The address that ownership of the contract is transferred to. This address may use `acceptOwnership()` to gain ownership of the contract.",
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Renounce ownership of the contract in a 2-step process. 1. the first call will initiate the process of renouncing ownership. 2. the second is used as a confirmation and will leave the contract without an owner. MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification WARNING: once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.",
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership renouncing process.",
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Sets singular data for a given `dataKey`",
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set Requirements: - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {ValueReceived} event when receiving native tokens. Emits a {DataChanged} event.",
        },
      },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Sets array of data for multiple given `dataKeys`",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues:
            "The array of values to set Requirements: - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {ValueReceived} event when receiving native tokens. Emits a {DataChanged} event. (on each iteration of setting data)",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns true if this contract implements the interface defined by `interfaceId`. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to LSP17, and checks if the extension implements the interface defined by `interfaceId`.",
      },
      userdoc: {
        notice:
          "Achieves the goal of ERC165 to detect supported interfaces and LSP17 by checking if the interfaceId being queried is supported on another linked extension.",
      },
    },

    /**
     * function transferOwnership(
     *  address _pendingOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [
        { internalType: "address", name: "_pendingOwner", type: "address" },
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Sets the pending owner address as an address that should call {acceptOwnership} in order to complete the ownership transfer of the account. Notifies the pending owner via LSP1Standard by calling {universalReceiver} on the pending owner if it's an address that supports LSP1.",
        params: {
          _pendingOwner:
            "The address of the new pending owner. Requirements: - MUST pass when called by the owner or by an authorized address that passes the verification check performed   on the owner according to LSP20 - CallVerification specification. - When notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferStarted'). - pending owner cannot accept ownership in the same tx via the LSP1 hook.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.",
      },
    },

    /**
     * function universalReceiver(
     *  bytes32 typeId,
     *  bytes receivedData
     * )
     *
     * 0x6bb56a14 = keccak256('universalReceiver(bytes32,bytes)')
     */
    "0x6bb56a14": {
      sig: "universalReceiver(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "typeId", type: "bytes32" },
        { internalType: "bytes", name: "receivedData", type: "bytes" },
      ],
      name: "universalReceiver",
      outputs: [
        { internalType: "bytes", name: "returnedValues", type: "bytes" },
      ],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "The function performs the following steps: - Emits {ValueReceived} when receiving native tokens. - Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY}.      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting        of 20 bytes of {msg.sender} and 32 bytes of {msg.value}. If not, continue the execution of the function. - Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY + <bytes32 typeId>}.   (Check {LSP2-ERC725YJSONSchema} for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting        of 20 bytes of {msg.sender} and 32 bytes of {msg.value}. If not, continue the execution of the function. - Emits a {UniversalReceiver} event.",
        params: {
          receivedData: "The data received.",
          typeId: "The type of call received.",
        },
        returns: {
          returnedValues:
            "The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP1-UniversalReceiver by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts (UniversalReceiverDelegates) that react on the whole transaction and on the specific typeId, respectively. The notification is achieved by emitting a {UniversalReceiver} event on the call with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract.",
      },
    },
  },
  LSP0ERC725AccountInit: {
    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()
     *
     * 0xead3fbdf = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()')
     */
    "0xead3fbdf": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()
     *
     * 0x01bfba61 = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()')
     */
    "0x01bfba61": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function acceptOwnership()
     *
     * 0x79ba5097 = keccak256('acceptOwnership()')
     */
    "0x79ba5097": {
      sig: "acceptOwnership()",
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfer ownership of the contract from the current `owner()` to the `pendingOwner()`. Once this function is called: - the current `owner()` will loose access to the functions restricted to the `owner()` only. - the `pendingOwner()` will gain access to the functions restricted to the `owner()` only. Requirements: - MUST be called by the pendingOwner. - When notifying the previous owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferred_SenderNotification'). - When notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferred_RecipientNotification').",
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.",
      },
    },

    /**
     * function batchCalls(
     *  bytes[] data
     * )
     *
     * 0x6963d438 = keccak256('batchCalls(bytes[])')
     */
    "0x6963d438": {
      sig: "batchCalls(bytes[])",
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "batchCalls",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Allows a caller to batch different function calls in one call. Perform a delegatecall on self, to call different functions with preserving the context It is not possible to send value along the functions call due to the use of delegatecall.",
        params: {
          data: "An array of ABI encoded function calls to be called on the contract.",
        },
        returns: {
          results: "An array of values returned by the executed functions.",
        },
      },
    },

    /**
     * function execute(
     *  uint256 operationType,
     *  address target,
     *  uint256 value,
     *  bytes data
     * )
     *
     * 0x44c028fe = keccak256('execute(uint256,address,uint256,bytes)')
     */
    "0x44c028fe": {
      sig: "execute(uint256,address,uint256,bytes)",
      inputs: [
        { internalType: "uint256", name: "operationType", type: "uint256" },
        { internalType: "address", name: "target", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "execute",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Executes any call on other addresses.",
        params: {
          data: "The call data to execute on `target`, or the bytecode of the contract to deploy Requirements: - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully. - if the operation type is {STATICCALL} or {DELEGATECALL}, `value` SHOULD be 0. - `target` SHOULD be address(0) when deploying a contract. - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4 Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 Emits a {ValueReceived} event when receiving native tokens.",
          operationType:
            "The operation to execute: CALL = 0 CREATE = 1 CREATE2 = 2 STATICCALL = 3 DELEGATECALL = 4",
          target:
            "The address (smart contract/EOA) to interact with, `target` will be unused if a contract is created (operation 1 and 2)",
          value: "The amount of native tokens to transfer (in Wei).",
        },
      },
    },

    /**
     * function executeBatch(
     *  uint256[] operationsType,
     *  address[] targets,
     *  uint256[] values,
     *  bytes[] datas
     * )
     *
     * 0x31858452 = keccak256('executeBatch(uint256[],address[],uint256[],bytes[])')
     */
    "0x31858452": {
      sig: "executeBatch(uint256[],address[],uint256[],bytes[])",
      inputs: [
        {
          internalType: "uint256[]",
          name: "operationsType",
          type: "uint256[]",
        },
        { internalType: "address[]", name: "targets", type: "address[]" },
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "datas", type: "bytes[]" },
      ],
      name: "executeBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Generic batch executor function that executes any call on other addresses",
        params: {
          datas:
            "The list of call data to execute on `targets`, or the creation bytecode of the contracts to deploy Requirements: - The length of the parameters provided MUST be equal - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully. - if the operation type is {STATICCALL} or {DELEGATECALL}, `value` SHOULD be 0. - `target` SHOULD be address(0) when deploying a contract. - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4 (each iteration) Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 (each iteration) Emits a {ValueReceived} event when receiving native tokens.",
          operationsType:
            "The list of operations type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",
          targets:
            "The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",
          values: "The list of native token amounts to transfer (in Wei)",
        },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function initialize(
     *  address newOwner
     * )
     *
     * 0xc4d66de8 = keccak256('initialize(address)')
     */
    "0xc4d66de8": {
      sig: "initialize(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "initialize",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Sets the owner of the contract",
        params: { newOwner: "the owner of the contract" },
      },
    },

    /**
     * function isValidSignature(
     *  bytes32 dataHash,
     *  bytes signature
     * )
     *
     * 0x1626ba7e = keccak256('isValidSignature(bytes32,bytes)')
     */
    "0x1626ba7e": {
      sig: "isValidSignature(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataHash", type: "bytes32" },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "isValidSignature",
      outputs: [{ internalType: "bytes4", name: "magicValue", type: "bytes4" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Handles two cases: - If the owner is an EOA, recovers an address from the hash and the signature provided:      - Returns the magicValue if the address recovered is the same as the owner, indicating        that it was a valid signature.      - If the address is different, it returns the fail value indicating that the signature is not valid. - If the owner is a smart contract, it forwards the call of {isValidSignature} to the owner contract:      - If the contract fails or returns the fail value, the {isValidSignature} on the account returns the        fail value, indicating that the signature is not valid.      - If the {isValidSignature} on the owner returned the magicValue, the {isValidSignature} on the account        returns the magicValue, indicating that it's a valid signature.",
        params: {
          dataHash: "The hash of the data to be validated.",
          signature:
            "A signature that can validate the previous parameter (Hash).",
        },
        returns: {
          magicValue:
            "A bytes4 value that indicates if the signature is valid or not.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of EIP-1271 by validating signatures of smart contracts according to their own logic.",
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function pendingOwner()
     *
     * 0xe30c3978 = keccak256('pendingOwner()')
     */
    "0xe30c3978": {
      sig: "pendingOwner()",
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "The address that ownership of the contract is transferred to. This address may use `acceptOwnership()` to gain ownership of the contract.",
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Renounce ownership of the contract in a 2-step process. 1. the first call will initiate the process of renouncing ownership. 2. the second is used as a confirmation and will leave the contract without an owner. MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification WARNING: once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.",
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership renouncing process.",
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Sets singular data for a given `dataKey`",
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set Requirements: - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {ValueReceived} event when receiving native tokens. Emits a {DataChanged} event.",
        },
      },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Sets array of data for multiple given `dataKeys`",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues:
            "The array of values to set Requirements: - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {ValueReceived} event when receiving native tokens. Emits a {DataChanged} event. (on each iteration of setting data)",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns true if this contract implements the interface defined by `interfaceId`. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to LSP17, and checks if the extension implements the interface defined by `interfaceId`.",
      },
      userdoc: {
        notice:
          "Achieves the goal of ERC165 to detect supported interfaces and LSP17 by checking if the interfaceId being queried is supported on another linked extension.",
      },
    },

    /**
     * function transferOwnership(
     *  address _pendingOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [
        { internalType: "address", name: "_pendingOwner", type: "address" },
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Sets the pending owner address as an address that should call {acceptOwnership} in order to complete the ownership transfer of the account. Notifies the pending owner via LSP1Standard by calling {universalReceiver} on the pending owner if it's an address that supports LSP1.",
        params: {
          _pendingOwner:
            "The address of the new pending owner. Requirements: - MUST pass when called by the owner or by an authorized address that passes the verification check performed   on the owner according to LSP20 - CallVerification specification. - When notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferStarted'). - pending owner cannot accept ownership in the same tx via the LSP1 hook.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.",
      },
    },

    /**
     * function universalReceiver(
     *  bytes32 typeId,
     *  bytes receivedData
     * )
     *
     * 0x6bb56a14 = keccak256('universalReceiver(bytes32,bytes)')
     */
    "0x6bb56a14": {
      sig: "universalReceiver(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "typeId", type: "bytes32" },
        { internalType: "bytes", name: "receivedData", type: "bytes" },
      ],
      name: "universalReceiver",
      outputs: [
        { internalType: "bytes", name: "returnedValues", type: "bytes" },
      ],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "The function performs the following steps: - Emits {ValueReceived} when receiving native tokens. - Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY}.      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting        of 20 bytes of {msg.sender} and 32 bytes of {msg.value}. If not, continue the execution of the function. - Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY + <bytes32 typeId>}.   (Check {LSP2-ERC725YJSONSchema} for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting        of 20 bytes of {msg.sender} and 32 bytes of {msg.value}. If not, continue the execution of the function. - Emits a {UniversalReceiver} event.",
        params: {
          receivedData: "The data received.",
          typeId: "The type of call received.",
        },
        returns: {
          returnedValues:
            "The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP1-UniversalReceiver by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts (UniversalReceiverDelegates) that react on the whole transaction and on the specific typeId, respectively. The notification is achieved by emitting a {UniversalReceiver} event on the call with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract.",
      },
    },
  },
  LSP11BasicSocialRecovery: {
    /**
     * function addGuardian(
     *  address newGuardian
     * )
     *
     * 0xa526d83b = keccak256('addGuardian(address)')
     */
    "0xa526d83b": {
      sig: "addGuardian(address)",
      inputs: [
        { internalType: "address", name: "newGuardian", type: "address" },
      ],
      name: "addGuardian",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Adds a guardian of the targetCan be called only by the owner",
        params: { newGuardian: "The address to add as a guardian" },
      },
    },

    /**
     * function getGuardianChoice(
     *  address guardian
     * )
     *
     * 0xf6a22f02 = keccak256('getGuardianChoice(address)')
     */
    "0xf6a22f02": {
      sig: "getGuardianChoice(address)",
      inputs: [{ internalType: "address", name: "guardian", type: "address" }],
      name: "getGuardianChoice",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the address of a controller that a `guardian` selected for in order to recover the target",
        params: {
          guardian: "the address of a guardian to query his selection",
        },
        returns: { _0: "the address that `guardian` selected" },
      },
    },

    /**
     * function getGuardians()
     *
     * 0x0665f04b = keccak256('getGuardians()')
     */
    "0x0665f04b": {
      sig: "getGuardians()",
      inputs: [],
      name: "getGuardians",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the addresses of all guardians The guardians will select an address to be added as a controller key for the linked `target` if he reaches the guardian threshold and provide the correct string that produce the secretHash",
      },
    },

    /**
     * function getGuardiansThreshold()
     *
     * 0x187c5348 = keccak256('getGuardiansThreshold()')
     */
    "0x187c5348": {
      sig: "getGuardiansThreshold()",
      inputs: [],
      name: "getGuardiansThreshold",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the guardian threshold The guardian threshold represents the minimum number of selection by guardians required for an address to start a recovery process",
      },
    },

    /**
     * function getRecoveryCounter()
     *
     * 0xf79c8b77 = keccak256('getRecoveryCounter()')
     */
    "0xf79c8b77": {
      sig: "getRecoveryCounter()",
      inputs: [],
      name: "getRecoveryCounter",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the current recovery counter When a recovery process is successfully finished the recovery counter is incremented",
      },
    },

    /**
     * function getRecoverySecretHash()
     *
     * 0x8f9083bb = keccak256('getRecoverySecretHash()')
     */
    "0x8f9083bb": {
      sig: "getRecoverySecretHash()",
      inputs: [],
      name: "getRecoverySecretHash",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the recovery secret hash" },
    },

    /**
     * function isGuardian(
     *  address _address
     * )
     *
     * 0x0c68ba21 = keccak256('isGuardian(address)')
     */
    "0x0c68ba21": {
      sig: "isGuardian(address)",
      inputs: [{ internalType: "address", name: "_address", type: "address" }],
      name: "isGuardian",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns TRUE if the address provided is a guardian, FALSE otherwise",
        params: { _address: "The address to query" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function recoverOwnership(
     *  address recoverer,
     *  string plainSecret,
     *  bytes32 newSecretHash
     * )
     *
     * 0xae8481b2 = keccak256('recoverOwnership(address,string,bytes32)')
     */
    "0xae8481b2": {
      sig: "recoverOwnership(address,string,bytes32)",
      inputs: [
        { internalType: "address", name: "recoverer", type: "address" },
        { internalType: "string", name: "plainSecret", type: "string" },
        { internalType: "bytes32", name: "newSecretHash", type: "bytes32" },
      ],
      name: "recoverOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Recovers the ownership permissions of an address in the linked target and increment the recover counter Requirements - the address of the recoverer must have a selection equal or higher than the threshold defined in `getGuardiansThreshold(...)` - must have provided the right `plainSecret` that produces the secret Hash",
        params: {
          newHash:
            "The new secret Hash to be used in the next recovery process",
          plainSecret: "The secret word that produce the secret Hash",
          recoverer: "The address of the recoverer",
        },
      },
    },

    /**
     * function removeGuardian(
     *  address existingGuardian
     * )
     *
     * 0x71404156 = keccak256('removeGuardian(address)')
     */
    "0x71404156": {
      sig: "removeGuardian(address)",
      inputs: [
        { internalType: "address", name: "existingGuardian", type: "address" },
      ],
      name: "removeGuardian",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes a guardian of the targetCan be called only by the owner",
        params: {
          currentGuardian:
            "The address of the existing guardian to remove Requirements: - The guardians count should be higher or equal to the guardain threshold",
        },
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function selectNewController(
     *  address addressSelected
     * )
     *
     * 0xaa7806d6 = keccak256('selectNewController(address)')
     */
    "0xaa7806d6": {
      sig: "selectNewController(address)",
      inputs: [
        { internalType: "address", name: "addressSelected", type: "address" },
      ],
      name: "selectNewController",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "select an address to be a potentiel controller address if he reaches the guardian threshold and provide the correct secret string Requirements: - only guardians can select an address",
        params: { addressSelected: "The address selected by the guardian" },
      },
    },

    /**
     * function setGuardiansThreshold(
     *  uint256 newThreshold
     * )
     *
     * 0x6bfed20b = keccak256('setGuardiansThreshold(uint256)')
     */
    "0x6bfed20b": {
      sig: "setGuardiansThreshold(uint256)",
      inputs: [
        { internalType: "uint256", name: "newThreshold", type: "uint256" },
      ],
      name: "setGuardiansThreshold",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Sets the minimum number of selection by the guardians required so that an address can recover ownershipCan be called only by the owner",
        params: {
          guardiansThreshold:
            "The threshold to set Requirements: - `guardiansThreshold` cannot be more than the guardians count.",
        },
      },
    },

    /**
     * function setRecoverySecretHash(
     *  bytes32 newRecoverSecretHash
     * )
     *
     * 0xf799e38d = keccak256('setRecoverySecretHash(bytes32)')
     */
    "0xf799e38d": {
      sig: "setRecoverySecretHash(bytes32)",
      inputs: [
        {
          internalType: "bytes32",
          name: "newRecoverSecretHash",
          type: "bytes32",
        },
      ],
      name: "setRecoverySecretHash",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Throws if hash provided is bytes32(0)",
        params: {
          newRecoverSecretHash:
            "The hash of the secret string Requirements: - `secretHash` cannot be bytes32(0)",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 _interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "_interfaceId", type: "bytes4" },
      ],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function target()
     *
     * 0xd4b83992 = keccak256('target()')
     */
    "0xd4b83992": {
      sig: "target()",
      inputs: [],
      name: "target",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "The address of an ERC725 contract where we want to recover and set permissions for a controller address",
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP11BasicSocialRecoveryInit: {
    /**
     * function addGuardian(
     *  address newGuardian
     * )
     *
     * 0xa526d83b = keccak256('addGuardian(address)')
     */
    "0xa526d83b": {
      sig: "addGuardian(address)",
      inputs: [
        { internalType: "address", name: "newGuardian", type: "address" },
      ],
      name: "addGuardian",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Adds a guardian of the targetCan be called only by the owner",
        params: { newGuardian: "The address to add as a guardian" },
      },
    },

    /**
     * function getGuardianChoice(
     *  address guardian
     * )
     *
     * 0xf6a22f02 = keccak256('getGuardianChoice(address)')
     */
    "0xf6a22f02": {
      sig: "getGuardianChoice(address)",
      inputs: [{ internalType: "address", name: "guardian", type: "address" }],
      name: "getGuardianChoice",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the address of a controller that a `guardian` selected for in order to recover the target",
        params: {
          guardian: "the address of a guardian to query his selection",
        },
        returns: { _0: "the address that `guardian` selected" },
      },
    },

    /**
     * function getGuardians()
     *
     * 0x0665f04b = keccak256('getGuardians()')
     */
    "0x0665f04b": {
      sig: "getGuardians()",
      inputs: [],
      name: "getGuardians",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the addresses of all guardians The guardians will select an address to be added as a controller key for the linked `target` if he reaches the guardian threshold and provide the correct string that produce the secretHash",
      },
    },

    /**
     * function getGuardiansThreshold()
     *
     * 0x187c5348 = keccak256('getGuardiansThreshold()')
     */
    "0x187c5348": {
      sig: "getGuardiansThreshold()",
      inputs: [],
      name: "getGuardiansThreshold",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the guardian threshold The guardian threshold represents the minimum number of selection by guardians required for an address to start a recovery process",
      },
    },

    /**
     * function getRecoveryCounter()
     *
     * 0xf79c8b77 = keccak256('getRecoveryCounter()')
     */
    "0xf79c8b77": {
      sig: "getRecoveryCounter()",
      inputs: [],
      name: "getRecoveryCounter",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the current recovery counter When a recovery process is successfully finished the recovery counter is incremented",
      },
    },

    /**
     * function getRecoverySecretHash()
     *
     * 0x8f9083bb = keccak256('getRecoverySecretHash()')
     */
    "0x8f9083bb": {
      sig: "getRecoverySecretHash()",
      inputs: [],
      name: "getRecoverySecretHash",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the recovery secret hash" },
    },

    /**
     * function initialize(
     *  address target_,
     *  address _owner
     * )
     *
     * 0x485cc955 = keccak256('initialize(address,address)')
     */
    "0x485cc955": {
      sig: "initialize(address,address)",
      inputs: [
        { internalType: "address", name: "target_", type: "address" },
        { internalType: "address", name: "_owner", type: "address" },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: {
          _owner: "The owner of the LSP11 contract",
          target_: "The address of the ER725 contract to recover",
        },
      },
      userdoc: { notice: "Sets the target and the owner addresses" },
    },

    /**
     * function isGuardian(
     *  address _address
     * )
     *
     * 0x0c68ba21 = keccak256('isGuardian(address)')
     */
    "0x0c68ba21": {
      sig: "isGuardian(address)",
      inputs: [{ internalType: "address", name: "_address", type: "address" }],
      name: "isGuardian",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns TRUE if the address provided is a guardian, FALSE otherwise",
        params: { _address: "The address to query" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function recoverOwnership(
     *  address recoverer,
     *  string plainSecret,
     *  bytes32 newSecretHash
     * )
     *
     * 0xae8481b2 = keccak256('recoverOwnership(address,string,bytes32)')
     */
    "0xae8481b2": {
      sig: "recoverOwnership(address,string,bytes32)",
      inputs: [
        { internalType: "address", name: "recoverer", type: "address" },
        { internalType: "string", name: "plainSecret", type: "string" },
        { internalType: "bytes32", name: "newSecretHash", type: "bytes32" },
      ],
      name: "recoverOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Recovers the ownership permissions of an address in the linked target and increment the recover counter Requirements - the address of the recoverer must have a selection equal or higher than the threshold defined in `getGuardiansThreshold(...)` - must have provided the right `plainSecret` that produces the secret Hash",
        params: {
          newHash:
            "The new secret Hash to be used in the next recovery process",
          plainSecret: "The secret word that produce the secret Hash",
          recoverer: "The address of the recoverer",
        },
      },
    },

    /**
     * function removeGuardian(
     *  address existingGuardian
     * )
     *
     * 0x71404156 = keccak256('removeGuardian(address)')
     */
    "0x71404156": {
      sig: "removeGuardian(address)",
      inputs: [
        { internalType: "address", name: "existingGuardian", type: "address" },
      ],
      name: "removeGuardian",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes a guardian of the targetCan be called only by the owner",
        params: {
          currentGuardian:
            "The address of the existing guardian to remove Requirements: - The guardians count should be higher or equal to the guardain threshold",
        },
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function selectNewController(
     *  address addressSelected
     * )
     *
     * 0xaa7806d6 = keccak256('selectNewController(address)')
     */
    "0xaa7806d6": {
      sig: "selectNewController(address)",
      inputs: [
        { internalType: "address", name: "addressSelected", type: "address" },
      ],
      name: "selectNewController",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "select an address to be a potentiel controller address if he reaches the guardian threshold and provide the correct secret string Requirements: - only guardians can select an address",
        params: { addressSelected: "The address selected by the guardian" },
      },
    },

    /**
     * function setGuardiansThreshold(
     *  uint256 newThreshold
     * )
     *
     * 0x6bfed20b = keccak256('setGuardiansThreshold(uint256)')
     */
    "0x6bfed20b": {
      sig: "setGuardiansThreshold(uint256)",
      inputs: [
        { internalType: "uint256", name: "newThreshold", type: "uint256" },
      ],
      name: "setGuardiansThreshold",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Sets the minimum number of selection by the guardians required so that an address can recover ownershipCan be called only by the owner",
        params: {
          guardiansThreshold:
            "The threshold to set Requirements: - `guardiansThreshold` cannot be more than the guardians count.",
        },
      },
    },

    /**
     * function setRecoverySecretHash(
     *  bytes32 newRecoverSecretHash
     * )
     *
     * 0xf799e38d = keccak256('setRecoverySecretHash(bytes32)')
     */
    "0xf799e38d": {
      sig: "setRecoverySecretHash(bytes32)",
      inputs: [
        {
          internalType: "bytes32",
          name: "newRecoverSecretHash",
          type: "bytes32",
        },
      ],
      name: "setRecoverySecretHash",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Throws if hash provided is bytes32(0)",
        params: {
          newRecoverSecretHash:
            "The hash of the secret string Requirements: - `secretHash` cannot be bytes32(0)",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 _interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [
        { internalType: "bytes4", name: "_interfaceId", type: "bytes4" },
      ],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function target()
     *
     * 0xd4b83992 = keccak256('target()')
     */
    "0xd4b83992": {
      sig: "target()",
      inputs: [],
      name: "target",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "The address of an ERC725 contract where we want to recover and set permissions for a controller address",
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP16UniversalFactory: {
    /**
     * function computeAddress(
     *  bytes32 byteCodeHash,
     *  bytes32 providedSalt,
     *  bool initializable,
     *  bytes initializeCalldata
     * )
     *
     * 0x3b315680 = keccak256('computeAddress(bytes32,bytes32,bool,bytes)')
     */
    "0x3b315680": {
      sig: "computeAddress(bytes32,bytes32,bool,bytes)",
      inputs: [
        { internalType: "bytes32", name: "byteCodeHash", type: "bytes32" },
        { internalType: "bytes32", name: "providedSalt", type: "bytes32" },
        { internalType: "bool", name: "initializable", type: "bool" },
        { internalType: "bytes", name: "initializeCalldata", type: "bytes" },
      ],
      name: "computeAddress",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Computes the address of a contract to be deployed using CREATE2, based on the input parameters. Any change in one of these parameters will result in a different address. When the `initializable` boolean is set to `false`, `initializeCalldata` will not affect the function output.",
        params: {
          byteCodeHash: "The keccak256 hash of the bytecode to be deployed",
          initializable:
            "A boolean that indicates whether an external call should be made to initialize the contract after deployment",
          initializeCalldata:
            "The calldata to be executed on the created contract if `initializable` is set to `true`",
          providedSalt:
            "The salt provided by the deployer, which will be used to generate the final salt that will be used by the `CREATE2` opcode for contract deployment",
        },
        returns: { _0: "The address where the contract will be deployed" },
      },
    },

    /**
     * function computeERC1167Address(
     *  address implementationContract,
     *  bytes32 providedSalt,
     *  bool initializable,
     *  bytes initializeCalldata
     * )
     *
     * 0xe888edcb = keccak256('computeERC1167Address(address,bytes32,bool,bytes)')
     */
    "0xe888edcb": {
      sig: "computeERC1167Address(address,bytes32,bool,bytes)",
      inputs: [
        {
          internalType: "address",
          name: "implementationContract",
          type: "address",
        },
        { internalType: "bytes32", name: "providedSalt", type: "bytes32" },
        { internalType: "bool", name: "initializable", type: "bool" },
        { internalType: "bytes", name: "initializeCalldata", type: "bytes" },
      ],
      name: "computeERC1167Address",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Computes the address of an ERC1167 proxy contract based on the input parameters. Any change in one of these parameters will result in a different address. When the `initializable` boolean is set to `false`, `initializeCalldata` will not affect the function output.",
        params: {
          implementationContract:
            "The contract to create a clone of according to ERC1167",
          initializable:
            "A boolean that indicates whether an external call should be made to initialize the proxy contract after deployment",
          initializeCalldata:
            "The calldata to be executed on the created contract if `initializable` is set to `true`",
          providedSalt:
            "The salt provided by the deployer, which will be used to generate the final salt that will be used by the `CREATE2` opcode for contract deployment",
        },
        returns: {
          _0: "The address where the ERC1167 proxy contract will be deployed",
        },
      },
    },

    /**
     * function deployCreate2(
     *  bytes byteCode,
     *  bytes32 providedSalt
     * )
     *
     * 0x26736355 = keccak256('deployCreate2(bytes,bytes32)')
     */
    "0x26736355": {
      sig: "deployCreate2(bytes,bytes32)",
      inputs: [
        { internalType: "bytes", name: "byteCode", type: "bytes" },
        { internalType: "bytes32", name: "providedSalt", type: "bytes32" },
      ],
      name: "deployCreate2",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Deploys a contract using the CREATE2 opcode. The address where the contract will be deployed can be known in advance via the {computeAddress} function. This function deploys contracts without initialization (external call after deployment). The `providedSalt` parameter is not used directly as the salt by the CREATE2 opcode. Instead, it is hashed with keccak256: `keccak256(abi.encodePacked(false, providedSalt))`. See {generateSalt} function for more details. Using the same `byteCode` and `providedSalt` multiple times will revert, as the contract cannot be deployed twice at the same address. If the constructor of the contract to deploy is payable, value can be sent to this function to fund the created contract. However, sending value to this function while the constructor is not payable will result in a revert.",
        params: {
          byteCode: "The bytecode of the contract to be deployed",
          providedSalt:
            "The salt provided by the deployer, which will be used to generate the final salt that will be used by the `CREATE2` opcode for contract deployment",
        },
        returns: { _0: "The address of the deployed contract" },
      },
    },

    /**
     * function deployCreate2AndInitialize(
     *  bytes byteCode,
     *  bytes32 providedSalt,
     *  bytes initializeCalldata,
     *  uint256 constructorMsgValue,
     *  uint256 initializeCalldataMsgValue
     * )
     *
     * 0xcdbd473a = keccak256('deployCreate2AndInitialize(bytes,bytes32,bytes,uint256,uint256)')
     */
    "0xcdbd473a": {
      sig: "deployCreate2AndInitialize(bytes,bytes32,bytes,uint256,uint256)",
      inputs: [
        { internalType: "bytes", name: "byteCode", type: "bytes" },
        { internalType: "bytes32", name: "providedSalt", type: "bytes32" },
        { internalType: "bytes", name: "initializeCalldata", type: "bytes" },
        {
          internalType: "uint256",
          name: "constructorMsgValue",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "initializeCalldataMsgValue",
          type: "uint256",
        },
      ],
      name: "deployCreate2AndInitialize",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Deploys a contract using the CREATE2 opcode. The address where the contract will be deployed can be known in advance via the {computeAddress} function. This function deploys contracts with initialization (external call after deployment). The `providedSalt` parameter is not used directly as the salt by the CREATE2 opcode. Instead, it is hashed with keccak256: `keccak256(abi.encodePacked(true, initializeCalldata, providedSalt))`. See {generateSalt} function for more details. Using the same `byteCode`, `providedSalt` and `initializeCalldata` multiple times will revert, as the contract cannot be deployed twice at the same address. If the constructor or the initialize function of the contract to deploy is payable, value can be sent along with the deployment/initialization to fund the created contract. However, sending value to this function while the constructor/initialize function is not payable will result in a revert. Will revert if the `msg.value` sent to the function is not equal to the sum of `constructorMsgValue` and `initializeCalldataMsgValue`.",
        params: {
          byteCode: "The bytecode of the contract to be deployed",
          constructorMsgValue:
            "The value sent to the contract during deployment",
          initializeCalldata:
            "The calldata to be executed on the created contract",
          initializeCalldataMsgValue:
            "The value sent to the contract during initialization",
          providedSalt:
            "The salt provided by the deployer, which will be used to generate the final salt that will be used by the `CREATE2` opcode for contract deployment",
        },
        returns: { _0: "The address of the deployed contract" },
      },
    },

    /**
     * function deployERC1167Proxy(
     *  address implementationContract,
     *  bytes32 providedSalt
     * )
     *
     * 0x49d8abed = keccak256('deployERC1167Proxy(address,bytes32)')
     */
    "0x49d8abed": {
      sig: "deployERC1167Proxy(address,bytes32)",
      inputs: [
        {
          internalType: "address",
          name: "implementationContract",
          type: "address",
        },
        { internalType: "bytes32", name: "providedSalt", type: "bytes32" },
      ],
      name: "deployERC1167Proxy",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Deploys an ERC1167 minimal proxy contract using the CREATE2 opcode. The address where the contract will be deployed can be known in advance via the {computeERC1167Address} function. This function deploys contracts without initialization (external call after deployment). The `providedSalt` parameter is not used directly as the salt by the CREATE2 opcode. Instead, it is hashed with keccak256: `keccak256(abi.encodePacked(false, providedSalt))`. See {generateSalt} function for more details. See {generateSalt} function for more details. Using the same `implementationContract` and `providedSalt` multiple times will revert, as the contract cannot be deployed twice at the same address. Sending value to the contract created is not possible since the constructor of the ERC1167 minimal proxy is not payable.",
        params: {
          implementationContract:
            "The contract address to use as the base implementation behind the proxy that will be deployed",
          providedSalt:
            "The salt provided by the deployer, which will be used to generate the final salt that will be used by the `CREATE2` opcode for contract deployment",
        },
        returns: { _0: "The address of the minimal proxy deployed" },
      },
    },

    /**
     * function deployERC1167ProxyAndInitialize(
     *  address implementationContract,
     *  bytes32 providedSalt,
     *  bytes initializeCalldata
     * )
     *
     * 0x5340165f = keccak256('deployERC1167ProxyAndInitialize(address,bytes32,bytes)')
     */
    "0x5340165f": {
      sig: "deployERC1167ProxyAndInitialize(address,bytes32,bytes)",
      inputs: [
        {
          internalType: "address",
          name: "implementationContract",
          type: "address",
        },
        { internalType: "bytes32", name: "providedSalt", type: "bytes32" },
        { internalType: "bytes", name: "initializeCalldata", type: "bytes" },
      ],
      name: "deployERC1167ProxyAndInitialize",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Deploys an ERC1167 minimal proxy contract using the CREATE2 opcode. The address where the contract will be deployed can be known in advance via the {computeERC1167Address} function. This function deploys contracts with initialization (external call after deployment). The `providedSalt` parameter is not used directly as the salt by the CREATE2 opcode. Instead, it is hashed with keccak256: `keccak256(abi.encodePacked(true, initializeCalldata, providedSalt))`. See {generateSalt} function for more details. Using the same `implementationContract`, `providedSalt` and `initializeCalldata` multiple times will revert, as the contract cannot be deployed twice at the same address. If the initialize function of the contract to deploy is payable, value can be sent along to fund the created contract while initializing. However, sending value to this function while the initialize function is not payable will result in a revert.",
        params: {
          implementationContract:
            "The contract address to use as the base implementation behind the proxy that will be deployed",
          initializeCalldata:
            "The calldata to be executed on the created contract",
          providedSalt:
            "The salt provided by the deployer, which will be used to generate the final salt that will be used by the `CREATE2` opcode for contract deployment",
        },
        returns: { _0: "The address of the minimal proxy deployed" },
      },
    },

    /**
     * function generateSalt(
     *  bytes32 providedSalt,
     *  bool initializable,
     *  bytes initializeCalldata
     * )
     *
     * 0x1a17ccbf = keccak256('generateSalt(bytes32,bool,bytes)')
     */
    "0x1a17ccbf": {
      sig: "generateSalt(bytes32,bool,bytes)",
      inputs: [
        { internalType: "bytes32", name: "providedSalt", type: "bytes32" },
        { internalType: "bool", name: "initializable", type: "bool" },
        { internalType: "bytes", name: "initializeCalldata", type: "bytes" },
      ],
      name: "generateSalt",
      outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
      stateMutability: "pure",
      type: "function",
      devdoc: {
        details:
          "Generates the salt used to deploy the contract by hashing the following parameters (concatenated together) with keccak256: - the `providedSalt` - the `initializable` boolean - the `initializeCalldata`, only if the contract is initializable (the `initializable` boolean is set to `true`) The `providedSalt` parameter is not used directly as the salt by the CREATE2 opcode. Instead, it is used along with these parameters:  - `initializable` boolean  - `initializeCalldata` (when the contract is initializable and `initializable` is set to `true`). These three parameters are concatenated together and hashed to generate the final salt for CREATE2. This approach ensures that in order to reproduce an initializable contract at the same address on another chain, not only the `providedSalt` is required to be the same, but also the initialize parameters within the `initializeCalldata` must also be the same. This maintains consistent deployment behaviour. Users are required to initialize contracts with the same parameters across different chains to ensure contracts are deployed at the same address across different chains. ----------- Example (for initializable contracts) For an existing contract A on chain 1 owned by X, to replicate the same contract at the same address with the same owner X on chain 2, the salt used to generate the address should include the initializeCalldata that assigns X as the owner of contract A. For instance, if another user, Y, tries to deploy the contract at the same address on chain 2 using the same providedSalt, but with a different initializeCalldata to make Y the owner instead of X, the generated address would be different, preventing Y from deploying the contract with different ownership at the same address. ----------- However, for non-initializable contracts, if the constructor has arguments that specify the deployment behavior, they will be included in the bytecode. Any change in the constructor arguments will lead to a different contract's bytecode which will result in a different address on other chains. ----------- Example (for non-initializable contracts) If a contract is deployed with specific constructor arguments on chain 1, these arguments are embedded within the bytecode. For instance, if contract B is deployed with a specific `tokenName` and `tokenSymbol` on chain 1, and a user wants to deploy the same contract with the same `tokenName` and `tokenSymbol` on chain 2, they must use the same constructor arguments to produce the same bytecode. This ensures that the same deployment behaviour is maintained across different chains, as long as the same bytecode is used. If another user Z, tries to deploy the same contract B at the same address on chain 2 using the same `providedSalt` but different constructor arguments (a different `tokenName` and/or `tokenSymbol`), the generated address will be different. This prevents user Z from deploying the contract with different constructor arguments at the same address on chain 2. ----------- The providedSalt was hashed to produce the salt used by CREATE2 opcode to prevent users from deploying initializable contracts using non-initializable functions such as {deployCreate2} without having the initialization call. In other words, if the providedSalt was not hashed and was used as it is as the salt by the CREATE2 opcode, malicious users can check the generated salt used for the already deployed initializable contract on chain 1, and deploy the contract from {deployCreate2} function on chain 2, with passing the generated salt of the deployed contract as providedSalt that will produce the same address but without the initialization, where the malicious user can initialize after.",
        params: {
          initializable:
            "The Boolean that specifies if the contract must be initialized or not",
          initializeCalldata:
            "The calldata to be executed on the created contract if `initializable` is set to `true`",
          providedSalt:
            "The salt provided by the deployer, which will be used to generate the final salt that will be used by the `CREATE2` opcode for contract deployment",
        },
        returns: {
          _0: "The generated salt which will be used for CREATE2 deployment",
        },
      },
    },
  },
  LSP1UniversalReceiverDelegateUP: {
    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function universalReceiver(
     *  bytes32 typeId,
     *  bytes
     * )
     *
     * 0x6bb56a14 = keccak256('universalReceiver(bytes32,bytes)')
     */
    "0x6bb56a14": {
      sig: "universalReceiver(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "typeId", type: "bytes32" },
        { internalType: "bytes", name: "", type: "bytes" },
      ],
      name: "universalReceiver",
      outputs: [{ internalType: "bytes", name: "result", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Handles two cases: - Registers the address of received assets (exclusively LSP7 and LSP8) and vaults (exclusively LSP9) according   to {LSP5-ReceivedAssets} and {LSP10-ReceivedVaults} respectively - Removes the address of registered assets and vaults when the full balance is sent from the LSP0ERC725Account contract Requirements: - The contract should be able to setData the LSP5 and LSP10 data Keys according to the logic of the owner    of the LSP0ERC725Account. - Cannot accept native tokens",
      },
    },
  },
  LSP1UniversalReceiverDelegateVault: {
    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function universalReceiver(
     *  bytes32 typeId,
     *  bytes
     * )
     *
     * 0x6bb56a14 = keccak256('universalReceiver(bytes32,bytes)')
     */
    "0x6bb56a14": {
      sig: "universalReceiver(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "typeId", type: "bytes32" },
        { internalType: "bytes", name: "", type: "bytes" },
      ],
      name: "universalReceiver",
      outputs: [{ internalType: "bytes", name: "result", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "allows to register arrayKeys and Map of incoming assets and remove after being sent",
        params: {
          data: "The arbitrary data received with the call",
          typeId: "The hash of a specific standard or a hook",
        },
        returns: { result: "The return value" },
      },
    },
  },
  LSP4Compatibility: {
    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function name()
     *
     * 0x06fdde03 = keccak256('name()')
     */
    "0x06fdde03": {
      sig: "name()",
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the name of the token.",
        returns: { _0: "The name of the token" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function symbol()
     *
     * 0x95d89b41 = keccak256('symbol()')
     */
    "0x95d89b41": {
      sig: "symbol()",
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the symbol of the token, usually a shorter version of the name.",
        returns: { _0: "The symbol of the token" },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP4DigitalAssetMetadata: {
    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP4DigitalAssetMetadataInitAbstract: {
    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP6KeyManager: {
    /**
     * function execute(
     *  bytes payload
     * )
     *
     * 0x09c5eabe = keccak256('execute(bytes)')
     */
    "0x09c5eabe": {
      sig: "execute(bytes)",
      inputs: [{ internalType: "bytes", name: "payload", type: "bytes" }],
      name: "execute",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "the ERC725Account will return some data on successful call, or revert on failure",
        params: {
          payload: "the payload to execute. Obtained in web3 via encodeABI()",
        },
        returns: { _0: "the data being returned by the ERC725 Account" },
      },
      userdoc: {
        notice: "execute the following payload on the ERC725Account: `payload`",
      },
    },

    /**
     * function executeBatch(
     *  uint256[] values,
     *  bytes[] payloads
     * )
     *
     * 0xbf0176ff = keccak256('executeBatch(uint256[],bytes[])')
     */
    "0xbf0176ff": {
      sig: "executeBatch(uint256[],bytes[])",
      inputs: [
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "payloads", type: "bytes[]" },
      ],
      name: "executeBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: { details: "batch `execute(bytes)`" },
    },

    /**
     * function executeRelayCall(
     *  bytes signature,
     *  uint256 nonce,
     *  uint256 validityTimestamps,
     *  bytes payload
     * )
     *
     * 0x4c8a4e74 = keccak256('executeRelayCall(bytes,uint256,uint256,bytes)')
     */
    "0x4c8a4e74": {
      sig: "executeRelayCall(bytes,uint256,uint256,bytes)",
      inputs: [
        { internalType: "bytes", name: "signature", type: "bytes" },
        { internalType: "uint256", name: "nonce", type: "uint256" },
        {
          internalType: "uint256",
          name: "validityTimestamps",
          type: "uint256",
        },
        { internalType: "bytes", name: "payload", type: "bytes" },
      ],
      name: "executeRelayCall",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "allows anybody to execute given they have a signed message from an executor",
        params: {
          nonce:
            "the address' nonce (in a specific `_channel`), obtained via `getNonce(...)`. Used to prevent replay attack",
          payload: "obtained via encodeABI() in web3",
          signature: "bytes32 ethereum signature",
          validityTimestamps:
            "two `uint128` timestamps concatenated, the first timestamp determines from when the payload can be executed, the second timestamp delimits the end of the validity of the payload. If `validityTimestamps` is 0, the checks regardin the timestamps are skipped",
        },
        returns: { _0: "the data being returned by the ERC725 Account" },
      },
    },

    /**
     * function executeRelayCallBatch(
     *  bytes[] signatures,
     *  uint256[] nonces,
     *  uint256[] validityTimestamps,
     *  uint256[] values,
     *  bytes[] payloads
     * )
     *
     * 0xa20856a5 = keccak256('executeRelayCallBatch(bytes[],uint256[],uint256[],uint256[],bytes[])')
     */
    "0xa20856a5": {
      sig: "executeRelayCallBatch(bytes[],uint256[],uint256[],uint256[],bytes[])",
      inputs: [
        { internalType: "bytes[]", name: "signatures", type: "bytes[]" },
        { internalType: "uint256[]", name: "nonces", type: "uint256[]" },
        {
          internalType: "uint256[]",
          name: "validityTimestamps",
          type: "uint256[]",
        },
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "payloads", type: "bytes[]" },
      ],
      name: "executeRelayCallBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: { details: "batch `executeRelayCall(...)`" },
    },

    /**
     * function getNonce(
     *  address from,
     *  uint128 channelId
     * )
     *
     * 0xb44581d9 = keccak256('getNonce(address,uint128)')
     */
    "0xb44581d9": {
      sig: "getNonce(address,uint128)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "uint128", name: "channelId", type: "uint128" },
      ],
      name: "getNonce",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "use channel ID = 0 for sequential nonces, any other number for out-of-order execution (= execution in parallel)",
        params: {
          channelId: "the channel id to retrieve the nonce from",
          from: "the caller or signer address",
        },
      },
      userdoc: {
        notice: "get latest nonce for `from` in channel ID: `channelId`",
      },
    },

    /**
     * function isValidSignature(
     *  bytes32 dataHash,
     *  bytes signature
     * )
     *
     * 0x1626ba7e = keccak256('isValidSignature(bytes32,bytes)')
     */
    "0x1626ba7e": {
      sig: "isValidSignature(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataHash", type: "bytes32" },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "isValidSignature",
      outputs: [{ internalType: "bytes4", name: "magicValue", type: "bytes4" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Should return whether the signature provided is valid for the provided data",
        params: {
          hash: "Hash of the data to be signed",
          signature: "Signature byte array associated with _data",
        },
      },
    },

    /**
     * function lsp20VerifyCall(
     *  address caller,
     *  uint256 msgValue,
     *  bytes data
     * )
     *
     * 0x9bf04b11 = keccak256('lsp20VerifyCall(address,uint256,bytes)')
     */
    "0x9bf04b11": {
      sig: "lsp20VerifyCall(address,uint256,bytes)",
      inputs: [
        { internalType: "address", name: "caller", type: "address" },
        { internalType: "uint256", name: "msgValue", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "lsp20VerifyCall",
      outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: {
          caller: "The address who called the function on the msg.sender",
          receivedCalldata:
            "The receivedCalldata sent by the caller to the msg.sender",
          value:
            "The value sent by the caller to the function called on the msg.sender",
        },
        returns: {
          _0: "MUST return the first 3 bytes of `lsp20VerifyCall(address,uint256,bytes)` function selector if the call to the function is allowed, concatened with a byte that determines if the lsp20VerifyCallResult function should be called after the original function call. The byte that invoke the lsp20VerifyCallResult function is strictly `0x01`.",
        },
      },
    },

    /**
     * function lsp20VerifyCallResult(
     *  bytes32 ,
     *  bytes
     * )
     *
     * 0xd3fc45d3 = keccak256('lsp20VerifyCallResult(bytes32,bytes)')
     */
    "0xd3fc45d3": {
      sig: "lsp20VerifyCallResult(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "", type: "bytes32" },
        { internalType: "bytes", name: "", type: "bytes" },
      ],
      name: "lsp20VerifyCallResult",
      outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: {
          callHash:
            "The keccak256 of the parameters of {lsp20VerifyCall} concatenated",
          result: "The value result of the function called on the msg.sender",
        },
        returns: {
          _0: "MUST return the lsp20VerifyCallResult function selector if the call to the function is allowed",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function target()
     *
     * 0xd4b83992 = keccak256('target()')
     */
    "0xd4b83992": {
      sig: "target()",
      inputs: [],
      name: "target",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "this can be a contract that implements  - ERC725X only  - ERC725Y only  - any ERC725 based contract (so implementing both ERC725X and ERC725Y)",
        returns: { _0: "the address of the linked account" },
      },
      userdoc: {
        notice: "returns the address of the account linked to this KeyManager",
      },
    },
  },
  LSP6KeyManagerInit: {
    /**
     * function execute(
     *  bytes payload
     * )
     *
     * 0x09c5eabe = keccak256('execute(bytes)')
     */
    "0x09c5eabe": {
      sig: "execute(bytes)",
      inputs: [{ internalType: "bytes", name: "payload", type: "bytes" }],
      name: "execute",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "the ERC725Account will return some data on successful call, or revert on failure",
        params: {
          payload: "the payload to execute. Obtained in web3 via encodeABI()",
        },
        returns: { _0: "the data being returned by the ERC725 Account" },
      },
      userdoc: {
        notice: "execute the following payload on the ERC725Account: `payload`",
      },
    },

    /**
     * function executeBatch(
     *  uint256[] values,
     *  bytes[] payloads
     * )
     *
     * 0xbf0176ff = keccak256('executeBatch(uint256[],bytes[])')
     */
    "0xbf0176ff": {
      sig: "executeBatch(uint256[],bytes[])",
      inputs: [
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "payloads", type: "bytes[]" },
      ],
      name: "executeBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: { details: "batch `execute(bytes)`" },
    },

    /**
     * function executeRelayCall(
     *  bytes signature,
     *  uint256 nonce,
     *  uint256 validityTimestamps,
     *  bytes payload
     * )
     *
     * 0x4c8a4e74 = keccak256('executeRelayCall(bytes,uint256,uint256,bytes)')
     */
    "0x4c8a4e74": {
      sig: "executeRelayCall(bytes,uint256,uint256,bytes)",
      inputs: [
        { internalType: "bytes", name: "signature", type: "bytes" },
        { internalType: "uint256", name: "nonce", type: "uint256" },
        {
          internalType: "uint256",
          name: "validityTimestamps",
          type: "uint256",
        },
        { internalType: "bytes", name: "payload", type: "bytes" },
      ],
      name: "executeRelayCall",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "allows anybody to execute given they have a signed message from an executor",
        params: {
          nonce:
            "the address' nonce (in a specific `_channel`), obtained via `getNonce(...)`. Used to prevent replay attack",
          payload: "obtained via encodeABI() in web3",
          signature: "bytes32 ethereum signature",
          validityTimestamps:
            "two `uint128` timestamps concatenated, the first timestamp determines from when the payload can be executed, the second timestamp delimits the end of the validity of the payload. If `validityTimestamps` is 0, the checks regardin the timestamps are skipped",
        },
        returns: { _0: "the data being returned by the ERC725 Account" },
      },
    },

    /**
     * function executeRelayCallBatch(
     *  bytes[] signatures,
     *  uint256[] nonces,
     *  uint256[] validityTimestamps,
     *  uint256[] values,
     *  bytes[] payloads
     * )
     *
     * 0xa20856a5 = keccak256('executeRelayCallBatch(bytes[],uint256[],uint256[],uint256[],bytes[])')
     */
    "0xa20856a5": {
      sig: "executeRelayCallBatch(bytes[],uint256[],uint256[],uint256[],bytes[])",
      inputs: [
        { internalType: "bytes[]", name: "signatures", type: "bytes[]" },
        { internalType: "uint256[]", name: "nonces", type: "uint256[]" },
        {
          internalType: "uint256[]",
          name: "validityTimestamps",
          type: "uint256[]",
        },
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "payloads", type: "bytes[]" },
      ],
      name: "executeRelayCallBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: { details: "batch `executeRelayCall(...)`" },
    },

    /**
     * function getNonce(
     *  address from,
     *  uint128 channelId
     * )
     *
     * 0xb44581d9 = keccak256('getNonce(address,uint128)')
     */
    "0xb44581d9": {
      sig: "getNonce(address,uint128)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "uint128", name: "channelId", type: "uint128" },
      ],
      name: "getNonce",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "use channel ID = 0 for sequential nonces, any other number for out-of-order execution (= execution in parallel)",
        params: {
          channelId: "the channel id to retrieve the nonce from",
          from: "the caller or signer address",
        },
      },
      userdoc: {
        notice: "get latest nonce for `from` in channel ID: `channelId`",
      },
    },

    /**
     * function initialize(
     *  address target_
     * )
     *
     * 0xc4d66de8 = keccak256('initialize(address)')
     */
    "0xc4d66de8": {
      sig: "initialize(address)",
      inputs: [{ internalType: "address", name: "target_", type: "address" }],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: { target_: "The address of the ER725Account to control" },
      },
      userdoc: {
        notice:
          "Initiate the account with the address of the ERC725Account contract and sets LSP6KeyManager InterfaceId",
      },
    },

    /**
     * function isValidSignature(
     *  bytes32 dataHash,
     *  bytes signature
     * )
     *
     * 0x1626ba7e = keccak256('isValidSignature(bytes32,bytes)')
     */
    "0x1626ba7e": {
      sig: "isValidSignature(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataHash", type: "bytes32" },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "isValidSignature",
      outputs: [{ internalType: "bytes4", name: "magicValue", type: "bytes4" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Should return whether the signature provided is valid for the provided data",
        params: {
          hash: "Hash of the data to be signed",
          signature: "Signature byte array associated with _data",
        },
      },
    },

    /**
     * function lsp20VerifyCall(
     *  address caller,
     *  uint256 msgValue,
     *  bytes data
     * )
     *
     * 0x9bf04b11 = keccak256('lsp20VerifyCall(address,uint256,bytes)')
     */
    "0x9bf04b11": {
      sig: "lsp20VerifyCall(address,uint256,bytes)",
      inputs: [
        { internalType: "address", name: "caller", type: "address" },
        { internalType: "uint256", name: "msgValue", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "lsp20VerifyCall",
      outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: {
          caller: "The address who called the function on the msg.sender",
          receivedCalldata:
            "The receivedCalldata sent by the caller to the msg.sender",
          value:
            "The value sent by the caller to the function called on the msg.sender",
        },
        returns: {
          _0: "MUST return the first 3 bytes of `lsp20VerifyCall(address,uint256,bytes)` function selector if the call to the function is allowed, concatened with a byte that determines if the lsp20VerifyCallResult function should be called after the original function call. The byte that invoke the lsp20VerifyCallResult function is strictly `0x01`.",
        },
      },
    },

    /**
     * function lsp20VerifyCallResult(
     *  bytes32 ,
     *  bytes
     * )
     *
     * 0xd3fc45d3 = keccak256('lsp20VerifyCallResult(bytes32,bytes)')
     */
    "0xd3fc45d3": {
      sig: "lsp20VerifyCallResult(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "", type: "bytes32" },
        { internalType: "bytes", name: "", type: "bytes" },
      ],
      name: "lsp20VerifyCallResult",
      outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: {
          callHash:
            "The keccak256 of the parameters of {lsp20VerifyCall} concatenated",
          result: "The value result of the function called on the msg.sender",
        },
        returns: {
          _0: "MUST return the lsp20VerifyCallResult function selector if the call to the function is allowed",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function target()
     *
     * 0xd4b83992 = keccak256('target()')
     */
    "0xd4b83992": {
      sig: "target()",
      inputs: [],
      name: "target",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "this can be a contract that implements  - ERC725X only  - ERC725Y only  - any ERC725 based contract (so implementing both ERC725X and ERC725Y)",
        returns: { _0: "the address of the linked account" },
      },
      userdoc: {
        notice: "returns the address of the account linked to this KeyManager",
      },
    },
  },
  LSP7DigitalAsset: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP7DigitalAssetInitAbstract: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP7CappedSupply: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function tokenSupplyCap()
     *
     * 0x52058d8a = keccak256('tokenSupplyCap()')
     */
    "0x52058d8a": {
      sig: "tokenSupplyCap()",
      inputs: [],
      name: "tokenSupplyCap",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens that can be minted",
        returns: { _0: "The number of tokens that can be minted" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP7CappedSupplyInitAbstract: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function tokenSupplyCap()
     *
     * 0x52058d8a = keccak256('tokenSupplyCap()')
     */
    "0x52058d8a": {
      sig: "tokenSupplyCap()",
      inputs: [],
      name: "tokenSupplyCap",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens that can be minted",
        returns: { _0: "The number of tokens that can be minted" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP7CompatibleERC20: {
    /**
     * function allowance(
     *  address tokenOwner,
     *  address operator
     * )
     *
     * 0xdd62ed3e = keccak256('allowance(address,address)')
     */
    "0xdd62ed3e": {
      sig: "allowance(address,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "allowance",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function approve(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x095ea7b3 = keccak256('approve(address,uint256)')
     */
    "0x095ea7b3": {
      sig: "approve(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function name()
     *
     * 0x06fdde03 = keccak256('name()')
     */
    "0x06fdde03": {
      sig: "name()",
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the name of the token.",
        returns: { _0: "The name of the token" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function symbol()
     *
     * 0x95d89b41 = keccak256('symbol()')
     */
    "0x95d89b41": {
      sig: "symbol()",
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the symbol of the token, usually a shorter version of the name.",
        returns: { _0: "The symbol of the token" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transfer(
     *  address to,
     *  uint256 amount
     * )
     *
     * 0xa9059cbb = keccak256('transfer(address,uint256)')
     */
    "0xa9059cbb": {
      sig: "transfer(address,uint256)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC20 transfer. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokens.",
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferFrom(
     *  address from,
     *  address to,
     *  uint256 amount
     * )
     *
     * 0x23b872dd = keccak256('transferFrom(address,address,uint256)')
     */
    "0x23b872dd": {
      sig: "transferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC20 transferFrom. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokens.",
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP7CompatibleERC20InitAbstract: {
    /**
     * function allowance(
     *  address tokenOwner,
     *  address operator
     * )
     *
     * 0xdd62ed3e = keccak256('allowance(address,address)')
     */
    "0xdd62ed3e": {
      sig: "allowance(address,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "allowance",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function approve(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x095ea7b3 = keccak256('approve(address,uint256)')
     */
    "0x095ea7b3": {
      sig: "approve(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function name()
     *
     * 0x06fdde03 = keccak256('name()')
     */
    "0x06fdde03": {
      sig: "name()",
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the name of the token.",
        returns: { _0: "The name of the token" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function symbol()
     *
     * 0x95d89b41 = keccak256('symbol()')
     */
    "0x95d89b41": {
      sig: "symbol()",
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the symbol of the token, usually a shorter version of the name.",
        returns: { _0: "The symbol of the token" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transfer(
     *  address to,
     *  uint256 amount
     * )
     *
     * 0xa9059cbb = keccak256('transfer(address,uint256)')
     */
    "0xa9059cbb": {
      sig: "transfer(address,uint256)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC20 transfer. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokens.",
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferFrom(
     *  address from,
     *  address to,
     *  uint256 amount
     * )
     *
     * 0x23b872dd = keccak256('transferFrom(address,address,uint256)')
     */
    "0x23b872dd": {
      sig: "transferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC20 transferFrom. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokens.",
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP7CompatibleERC20Mintable: {
    /**
     * function allowance(
     *  address tokenOwner,
     *  address operator
     * )
     *
     * 0xdd62ed3e = keccak256('allowance(address,address)')
     */
    "0xdd62ed3e": {
      sig: "allowance(address,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "allowance",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function approve(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x095ea7b3 = keccak256('approve(address,uint256)')
     */
    "0x095ea7b3": {
      sig: "approve(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function mint(
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x7580d920 = keccak256('mint(address,uint256,bool,bytes)')
     */
    "0x7580d920": {
      sig: "mint(address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function name()
     *
     * 0x06fdde03 = keccak256('name()')
     */
    "0x06fdde03": {
      sig: "name()",
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the name of the token.",
        returns: { _0: "The name of the token" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function symbol()
     *
     * 0x95d89b41 = keccak256('symbol()')
     */
    "0x95d89b41": {
      sig: "symbol()",
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the symbol of the token, usually a shorter version of the name.",
        returns: { _0: "The symbol of the token" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transfer(
     *  address to,
     *  uint256 amount
     * )
     *
     * 0xa9059cbb = keccak256('transfer(address,uint256)')
     */
    "0xa9059cbb": {
      sig: "transfer(address,uint256)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC20 transfer. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokens.",
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferFrom(
     *  address from,
     *  address to,
     *  uint256 amount
     * )
     *
     * 0x23b872dd = keccak256('transferFrom(address,address,uint256)')
     */
    "0x23b872dd": {
      sig: "transferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC20 transferFrom. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokens.",
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP7CompatibleERC20MintableInit: {
    /**
     * function allowance(
     *  address tokenOwner,
     *  address operator
     * )
     *
     * 0xdd62ed3e = keccak256('allowance(address,address)')
     */
    "0xdd62ed3e": {
      sig: "allowance(address,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "allowance",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function approve(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x095ea7b3 = keccak256('approve(address,uint256)')
     */
    "0x095ea7b3": {
      sig: "approve(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function initialize(
     *  string name_,
     *  string symbol_,
     *  address newOwner_
     * )
     *
     * 0x077f224a = keccak256('initialize(string,string,address)')
     */
    "0x077f224a": {
      sig: "initialize(string,string,address)",
      inputs: [
        { internalType: "string", name: "name_", type: "string" },
        { internalType: "string", name: "symbol_", type: "string" },
        { internalType: "address", name: "newOwner_", type: "address" },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: {
          name_: "The name of the token",
          newOwner_: "The owner of the token",
          symbol_: "The symbol of the token",
        },
      },
      userdoc: {
        notice: "Sets the name, the symbol and the owner of the token",
      },
    },

    /**
     * function mint(
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x7580d920 = keccak256('mint(address,uint256,bool,bytes)')
     */
    "0x7580d920": {
      sig: "mint(address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function name()
     *
     * 0x06fdde03 = keccak256('name()')
     */
    "0x06fdde03": {
      sig: "name()",
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the name of the token.",
        returns: { _0: "The name of the token" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function symbol()
     *
     * 0x95d89b41 = keccak256('symbol()')
     */
    "0x95d89b41": {
      sig: "symbol()",
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the symbol of the token, usually a shorter version of the name.",
        returns: { _0: "The symbol of the token" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transfer(
     *  address to,
     *  uint256 amount
     * )
     *
     * 0xa9059cbb = keccak256('transfer(address,uint256)')
     */
    "0xa9059cbb": {
      sig: "transfer(address,uint256)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC20 transfer. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokens.",
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferFrom(
     *  address from,
     *  address to,
     *  uint256 amount
     * )
     *
     * 0x23b872dd = keccak256('transferFrom(address,address,uint256)')
     */
    "0x23b872dd": {
      sig: "transferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC20 transferFrom. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokens.",
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP7Mintable: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function mint(
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x7580d920 = keccak256('mint(address,uint256,bool,bytes)')
     */
    "0x7580d920": {
      sig: "mint(address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Mints `amount` tokens and transfers it to `to`. Requirements: - `to` cannot be the zero address. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount to mint",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          to: "The address to mint tokens",
        },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP7MintableInit: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  uint256 amount
     * )
     *
     * 0x47980aa3 = keccak256('authorizeOperator(address,uint256)')
     */
    "0x47980aa3": {
      sig: "authorizeOperator(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "To avoid front-running and Allowance Double-Spend Exploit when increasing or decreasing the authorized amount of an operator, it is advised to:     1. call {revokeOperator} first, and     2. then re-call {authorizeOperator} with the new amount for more information, see: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/",
        params: {
          amount: "The amount of tokens operator has access to.",
          operator: "The address to authorize as an operator.",
        },
      },
    },

    /**
     * function authorizedAmountFor(
     *  address operator,
     *  address tokenOwner
     * )
     *
     * 0x65aeaa95 = keccak256('authorizedAmountFor(address,address)')
     */
    "0x65aeaa95": {
      sig: "authorizedAmountFor(address,address)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "authorizedAmountFor",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns amount of tokens `operator` address has access to from `tokenOwner`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.",
        params: {
          operator: "The address to query operator status for.",
          tokenOwner: "The token owner.",
        },
        returns: {
          _0: "The amount of tokens `operator` address has access to from `tokenOwner`.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function decimals()
     *
     * 0x313ce567 = keccak256('decimals()')
     */
    "0x313ce567": {
      sig: "decimals()",
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the number of decimals used to get its user representation If the contract represents a NFT then 0 SHOULD be used, otherwise 18 is the common value NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {balanceOf} and {transfer}.",
      },
    },

    /**
     * function decreaseAllowance(
     *  address operator,
     *  uint256 substractedAmount
     * )
     *
     * 0xa457c2d7 = keccak256('decreaseAllowance(address,uint256)')
     */
    "0xa457c2d7": {
      sig: "decreaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "substractedAmount", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically decreases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset} Emits:  - an {AuthorizedOperator} event indicating the updated allowance after decreasing it.  - a {RevokeOperator} event if `substractedAmount` is the full allowance,    indicating `operator` does not have any allowance left for `msg.sender`.Requirements:  - `operator` cannot be the zero address.  - operator` must have allowance for the caller of at least `substractedAmount`.",
        params: {
          operator: "the operator to decrease allowance for `msg.sender`",
          substractedAmount:
            "the amount to decrease by in the operator's allowance.",
        },
      },
      userdoc: {
        notice: "Decrease the allowance of `operator` by -`substractedAmount`",
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function increaseAllowance(
     *  address operator,
     *  uint256 addedAmount
     * )
     *
     * 0x39509351 = keccak256('increaseAllowance(address,uint256)')
     */
    "0x39509351": {
      sig: "increaseAllowance(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "addedAmount", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Atomically increases the allowance granted to `operator` by the caller. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for problems described in {ILSP7DigitalAsset}. Emits an {AuthorizedOperator} event indicating the updated allowance.Requirements:  - `operator` cannot be the same address as `msg.sender`  - `operator` cannot be the zero address.",
        params: {
          addedAmount:
            "the additional amount to add on top of the current operator's allowance",
          operator: "the operator to increase the allowance for `msg.sender`",
        },
      },
      userdoc: {
        notice: "Increase the allowance of `operator` by +`addedAmount`",
      },
    },

    /**
     * function initialize(
     *  string name_,
     *  string symbol_,
     *  address newOwner_,
     *  bool isNonDivisible_
     * )
     *
     * 0x5c108a43 = keccak256('initialize(string,string,address,bool)')
     */
    "0x5c108a43": {
      sig: "initialize(string,string,address,bool)",
      inputs: [
        { internalType: "string", name: "name_", type: "string" },
        { internalType: "string", name: "symbol_", type: "string" },
        { internalType: "address", name: "newOwner_", type: "address" },
        { internalType: "bool", name: "isNonDivisible_", type: "bool" },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: {
          isNonDivisible_:
            "Specify if the LSP7 token is a fungible or non-fungible token",
          name_: "The name of the token",
          newOwner_: "The owner of the the token-Metadata",
          symbol_: "The symbol of the token",
        },
      },
      userdoc: {
        notice: "Sets the token-Metadata and register LSP7InterfaceId",
      },
    },

    /**
     * function mint(
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x7580d920 = keccak256('mint(address,uint256,bool,bytes)')
     */
    "0x7580d920": {
      sig: "mint(address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Mints `amount` tokens and transfers it to `to`. Requirements: - `to` cannot be the zero address. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount to mint",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          to: "The address to mint tokens",
        },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator
     * )
     *
     * 0xfad8b32a = keccak256('revokeOperator(address)')
     */
    "0xfad8b32a": {
      sig: "revokeOperator(address)",
      inputs: [{ internalType: "address", name: "operator", type: "address" }],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of callers tokens. See {authorizedAmountFor}. Requirements - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: { operator: "The address to revoke as an operator." },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  uint256 amount,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x760d9bba = keccak256('transfer(address,address,uint256,bool,bytes)')
     */
    "0x760d9bba": {
      sig: "transfer(address,address,uint256,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `amount` of tokens from `from` to `to`. The `allowNonLSP1Recipient` parameter will be used when notifying the token sender and receiver. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  uint256[] amount,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x2d7667c9 = keccak256('transferBatch(address[],address[],uint256[],bool[],bytes[])')
     */
    "0x2d7667c9": {
      sig: "transferBatch(address[],address[],uint256[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "uint256[]", name: "amount", type: "uint256[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `amount` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - each `amount` tokens must be owned by `from`. - If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          amount: "The amount of tokens to transfer.",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8IdentifiableDigitalAsset: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8IdentifiableDigitalAssetInitAbstract: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8CappedSupply: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function tokenSupplyCap()
     *
     * 0x52058d8a = keccak256('tokenSupplyCap()')
     */
    "0x52058d8a": {
      sig: "tokenSupplyCap()",
      inputs: [],
      name: "tokenSupplyCap",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens that can be minted.",
        returns: { _0: "The token max supply" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8CappedSupplyInitAbstract: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function tokenSupplyCap()
     *
     * 0x52058d8a = keccak256('tokenSupplyCap()')
     */
    "0x52058d8a": {
      sig: "tokenSupplyCap()",
      inputs: [],
      name: "tokenSupplyCap",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens that can be minted.",
        returns: { _0: "The token max supply" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8CompatibleERC721: {
    /**
     * function approve(
     *  address operator,
     *  uint256 tokenId
     * )
     *
     * 0x095ea7b3 = keccak256('approve(address,uint256)')
     */
    "0x095ea7b3": {
      sig: "approve(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 approve.",
        params: {
          operator: "The address to approve for `tokenId`",
          tokenId: "The tokenId to approve",
        },
      },
    },

    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getApproved(
     *  uint256 tokenId
     * )
     *
     * 0x081812fc = keccak256('getApproved(uint256)')
     */
    "0x081812fc": {
      sig: "getApproved(uint256)",
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 getApproved.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address of the operator for `tokenId`" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function isApprovedForAll(
     *  address tokenOwner,
     *  address operator
     * )
     *
     * 0xe985e9c5 = keccak256('isApprovedForAll(address,address)')
     */
    "0xe985e9c5": {
      sig: "isApprovedForAll(address,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function name()
     *
     * 0x06fdde03 = keccak256('name()')
     */
    "0x06fdde03": {
      sig: "name()",
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the name of the token.",
        returns: { _0: "The name of the token" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function ownerOf(
     *  uint256 tokenId
     * )
     *
     * 0x6352211e = keccak256('ownerOf(uint256)')
     */
    "0x6352211e": {
      sig: "ownerOf(uint256)",
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 ownerOf.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The owner of the tokenId" },
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function safeTransferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId
     * )
     *
     * 0x42842e0e = keccak256('safeTransferFrom(address,address,uint256)')
     */
    "0x42842e0e": {
      sig: "safeTransferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC721 safeTransferFrom (without optional data). Using allowNonLSP1Recipient=false so that no EOA and only contracts supporting LSP1 interface may receive the tokenId.",
        params: {
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function safeTransferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId,
     *  bytes data
     * )
     *
     * 0xb88d4fde = keccak256('safeTransferFrom(address,address,uint256,bytes)')
     */
    "0xb88d4fde": {
      sig: "safeTransferFrom(address,address,uint256,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 safeTransferFrom.",
        params: {
          data: "The data to be sent with the transfer",
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function setApprovalForAll(
     *  address operator,
     *  bool approved
     * )
     *
     * 0xa22cb465 = keccak256('setApprovalForAll(address,bool)')
     */
    "0xa22cb465": {
      sig: "setApprovalForAll(address,bool)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: { details: "See _setApprovalForAll" },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function symbol()
     *
     * 0x95d89b41 = keccak256('symbol()')
     */
    "0x95d89b41": {
      sig: "symbol()",
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the symbol of the token, usually a shorter version of the name.",
        returns: { _0: "The symbol of the token" },
      },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function tokenURI(
     *  uint256
     * )
     *
     * 0xc87b56dd = keccak256('tokenURI(uint256)')
     */
    "0xc87b56dd": {
      sig: "tokenURI(uint256)",
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId
     * )
     *
     * 0x23b872dd = keccak256('transferFrom(address,address,uint256)')
     */
    "0x23b872dd": {
      sig: "transferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC721 transferFrom. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokenId.",
        params: {
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8CompatibleERC721InitAbstract: {
    /**
     * function approve(
     *  address operator,
     *  uint256 tokenId
     * )
     *
     * 0x095ea7b3 = keccak256('approve(address,uint256)')
     */
    "0x095ea7b3": {
      sig: "approve(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 approve.",
        params: {
          operator: "The address to approve for `tokenId`",
          tokenId: "The tokenId to approve",
        },
      },
    },

    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getApproved(
     *  uint256 tokenId
     * )
     *
     * 0x081812fc = keccak256('getApproved(uint256)')
     */
    "0x081812fc": {
      sig: "getApproved(uint256)",
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 getApproved.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address of the operator for `tokenId`" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function isApprovedForAll(
     *  address tokenOwner,
     *  address operator
     * )
     *
     * 0xe985e9c5 = keccak256('isApprovedForAll(address,address)')
     */
    "0xe985e9c5": {
      sig: "isApprovedForAll(address,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function name()
     *
     * 0x06fdde03 = keccak256('name()')
     */
    "0x06fdde03": {
      sig: "name()",
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the name of the token.",
        returns: { _0: "The name of the token" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function ownerOf(
     *  uint256 tokenId
     * )
     *
     * 0x6352211e = keccak256('ownerOf(uint256)')
     */
    "0x6352211e": {
      sig: "ownerOf(uint256)",
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 ownerOf.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The owner of the tokenId" },
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function safeTransferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId
     * )
     *
     * 0x42842e0e = keccak256('safeTransferFrom(address,address,uint256)')
     */
    "0x42842e0e": {
      sig: "safeTransferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC721 safeTransferFrom (without optional data). Using allowNonLSP1Recipient=false so that no EOA and only contracts supporting LSP1 interface may receive the tokenId.",
        params: {
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function safeTransferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId,
     *  bytes data
     * )
     *
     * 0xb88d4fde = keccak256('safeTransferFrom(address,address,uint256,bytes)')
     */
    "0xb88d4fde": {
      sig: "safeTransferFrom(address,address,uint256,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 safeTransferFrom.",
        params: {
          data: "The data to be sent with the transfer",
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function setApprovalForAll(
     *  address operator,
     *  bool approved
     * )
     *
     * 0xa22cb465 = keccak256('setApprovalForAll(address,bool)')
     */
    "0xa22cb465": {
      sig: "setApprovalForAll(address,bool)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: { details: "See _setApprovalForAll" },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function symbol()
     *
     * 0x95d89b41 = keccak256('symbol()')
     */
    "0x95d89b41": {
      sig: "symbol()",
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the symbol of the token, usually a shorter version of the name.",
        returns: { _0: "The symbol of the token" },
      },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function tokenURI(
     *  uint256
     * )
     *
     * 0xc87b56dd = keccak256('tokenURI(uint256)')
     */
    "0xc87b56dd": {
      sig: "tokenURI(uint256)",
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId
     * )
     *
     * 0x23b872dd = keccak256('transferFrom(address,address,uint256)')
     */
    "0x23b872dd": {
      sig: "transferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC721 transferFrom. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokenId.",
        params: {
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8CompatibleERC721Mintable: {
    /**
     * function approve(
     *  address operator,
     *  uint256 tokenId
     * )
     *
     * 0x095ea7b3 = keccak256('approve(address,uint256)')
     */
    "0x095ea7b3": {
      sig: "approve(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 approve.",
        params: {
          operator: "The address to approve for `tokenId`",
          tokenId: "The tokenId to approve",
        },
      },
    },

    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getApproved(
     *  uint256 tokenId
     * )
     *
     * 0x081812fc = keccak256('getApproved(uint256)')
     */
    "0x081812fc": {
      sig: "getApproved(uint256)",
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 getApproved.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address of the operator for `tokenId`" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function isApprovedForAll(
     *  address tokenOwner,
     *  address operator
     * )
     *
     * 0xe985e9c5 = keccak256('isApprovedForAll(address,address)')
     */
    "0xe985e9c5": {
      sig: "isApprovedForAll(address,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function mint(
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xaf255b61 = keccak256('mint(address,bytes32,bool,bytes)')
     */
    "0xaf255b61": {
      sig: "mint(address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function name()
     *
     * 0x06fdde03 = keccak256('name()')
     */
    "0x06fdde03": {
      sig: "name()",
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the name of the token.",
        returns: { _0: "The name of the token" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function ownerOf(
     *  uint256 tokenId
     * )
     *
     * 0x6352211e = keccak256('ownerOf(uint256)')
     */
    "0x6352211e": {
      sig: "ownerOf(uint256)",
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 ownerOf.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The owner of the tokenId" },
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function safeTransferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId
     * )
     *
     * 0x42842e0e = keccak256('safeTransferFrom(address,address,uint256)')
     */
    "0x42842e0e": {
      sig: "safeTransferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC721 safeTransferFrom (without optional data). Using allowNonLSP1Recipient=false so that no EOA and only contracts supporting LSP1 interface may receive the tokenId.",
        params: {
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function safeTransferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId,
     *  bytes data
     * )
     *
     * 0xb88d4fde = keccak256('safeTransferFrom(address,address,uint256,bytes)')
     */
    "0xb88d4fde": {
      sig: "safeTransferFrom(address,address,uint256,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 safeTransferFrom.",
        params: {
          data: "The data to be sent with the transfer",
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function setApprovalForAll(
     *  address operator,
     *  bool approved
     * )
     *
     * 0xa22cb465 = keccak256('setApprovalForAll(address,bool)')
     */
    "0xa22cb465": {
      sig: "setApprovalForAll(address,bool)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: { details: "See _setApprovalForAll" },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function symbol()
     *
     * 0x95d89b41 = keccak256('symbol()')
     */
    "0x95d89b41": {
      sig: "symbol()",
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the symbol of the token, usually a shorter version of the name.",
        returns: { _0: "The symbol of the token" },
      },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function tokenURI(
     *  uint256
     * )
     *
     * 0xc87b56dd = keccak256('tokenURI(uint256)')
     */
    "0xc87b56dd": {
      sig: "tokenURI(uint256)",
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId
     * )
     *
     * 0x23b872dd = keccak256('transferFrom(address,address,uint256)')
     */
    "0x23b872dd": {
      sig: "transferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC721 transferFrom. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokenId.",
        params: {
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8CompatibleERC721MintableInit: {
    /**
     * function approve(
     *  address operator,
     *  uint256 tokenId
     * )
     *
     * 0x095ea7b3 = keccak256('approve(address,uint256)')
     */
    "0x095ea7b3": {
      sig: "approve(address,uint256)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 approve.",
        params: {
          operator: "The address to approve for `tokenId`",
          tokenId: "The tokenId to approve",
        },
      },
    },

    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getApproved(
     *  uint256 tokenId
     * )
     *
     * 0x081812fc = keccak256('getApproved(uint256)')
     */
    "0x081812fc": {
      sig: "getApproved(uint256)",
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "getApproved",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 getApproved.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address of the operator for `tokenId`" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function initialize(
     *  string name_,
     *  string symbol_,
     *  address newOwner_
     * )
     *
     * 0x077f224a = keccak256('initialize(string,string,address)')
     */
    "0x077f224a": {
      sig: "initialize(string,string,address)",
      inputs: [
        { internalType: "string", name: "name_", type: "string" },
        { internalType: "string", name: "symbol_", type: "string" },
        { internalType: "address", name: "newOwner_", type: "address" },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: {
          name_: "The name of the token",
          newOwner_: "The owner of the token",
          symbol_: "The symbol of the token",
        },
      },
      userdoc: {
        notice: "Sets the name, the symbol and the owner of the token",
      },
    },

    /**
     * function isApprovedForAll(
     *  address tokenOwner,
     *  address operator
     * )
     *
     * 0xe985e9c5 = keccak256('isApprovedForAll(address,address)')
     */
    "0xe985e9c5": {
      sig: "isApprovedForAll(address,address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function mint(
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xaf255b61 = keccak256('mint(address,bytes32,bool,bytes)')
     */
    "0xaf255b61": {
      sig: "mint(address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function name()
     *
     * 0x06fdde03 = keccak256('name()')
     */
    "0x06fdde03": {
      sig: "name()",
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the name of the token.",
        returns: { _0: "The name of the token" },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function ownerOf(
     *  uint256 tokenId
     * )
     *
     * 0x6352211e = keccak256('ownerOf(uint256)')
     */
    "0x6352211e": {
      sig: "ownerOf(uint256)",
      inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
      name: "ownerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 ownerOf.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The owner of the tokenId" },
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function safeTransferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId
     * )
     *
     * 0x42842e0e = keccak256('safeTransferFrom(address,address,uint256)')
     */
    "0x42842e0e": {
      sig: "safeTransferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC721 safeTransferFrom (without optional data). Using allowNonLSP1Recipient=false so that no EOA and only contracts supporting LSP1 interface may receive the tokenId.",
        params: {
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function safeTransferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId,
     *  bytes data
     * )
     *
     * 0xb88d4fde = keccak256('safeTransferFrom(address,address,uint256,bytes)')
     */
    "0xb88d4fde": {
      sig: "safeTransferFrom(address,address,uint256,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details: "Compatible with ERC721 safeTransferFrom.",
        params: {
          data: "The data to be sent with the transfer",
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function setApprovalForAll(
     *  address operator,
     *  bool approved
     * )
     *
     * 0xa22cb465 = keccak256('setApprovalForAll(address,bool)')
     */
    "0xa22cb465": {
      sig: "setApprovalForAll(address,bool)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: { details: "See _setApprovalForAll" },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function symbol()
     *
     * 0x95d89b41 = keccak256('symbol()')
     */
    "0x95d89b41": {
      sig: "symbol()",
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the symbol of the token, usually a shorter version of the name.",
        returns: { _0: "The symbol of the token" },
      },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function tokenURI(
     *  uint256
     * )
     *
     * 0xc87b56dd = keccak256('tokenURI(uint256)')
     */
    "0xc87b56dd": {
      sig: "tokenURI(uint256)",
      inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      name: "tokenURI",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferFrom(
     *  address from,
     *  address to,
     *  uint256 tokenId
     * )
     *
     * 0x23b872dd = keccak256('transferFrom(address,address,uint256)')
     */
    "0x23b872dd": {
      sig: "transferFrom(address,address,uint256)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "tokenId", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Compatible with ERC721 transferFrom. Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokenId.",
        params: {
          from: "The sending address",
          to: "The receiving address",
          tokenId: "The tokenId to transfer",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8Mintable: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function mint(
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xaf255b61 = keccak256('mint(address,bytes32,bool,bytes)')
     */
    "0xaf255b61": {
      sig: "mint(address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Mints `amount` tokens and transfers it to `to`. Requirements: - `to` cannot be the zero address. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          to: "The address to mint tokens",
          tokenId: "The tokenId to mint",
        },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP8MintableInit: {
    /**
     * function authorizeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0xcf5182ba = keccak256('authorizeOperator(address,bytes32)')
     */
    "0xcf5182ba": {
      sig: "authorizeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "authorizeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Makes `operator` address an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits an {AuthorizedOperator} event.",
        params: {
          operator: "The address to authorize as an operator.",
          tokenId: "The tokenId operator has access to.",
        },
      },
    },

    /**
     * function balanceOf(
     *  address tokenOwner
     * )
     *
     * 0x70a08231 = keccak256('balanceOf(address)')
     */
    "0x70a08231": {
      sig: "balanceOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of tokens owned by `tokenOwner`.",
        params: { tokenOwner: "The address to query" },
        returns: { _0: "The number of tokens owned by this address" },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function getOperatorsOf(
     *  bytes32 tokenId
     * )
     *
     * 0x49a6078d = keccak256('getOperatorsOf(bytes32)')
     */
    "0x49a6078d": {
      sig: "getOperatorsOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "getOperatorsOf",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns all `operator` addresses of `tokenId`. Requirements - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The list of operators for the `tokenId`" },
      },
    },

    /**
     * function initialize(
     *  string name_,
     *  string symbol_,
     *  address newOwner_
     * )
     *
     * 0x077f224a = keccak256('initialize(string,string,address)')
     */
    "0x077f224a": {
      sig: "initialize(string,string,address)",
      inputs: [
        { internalType: "string", name: "name_", type: "string" },
        { internalType: "string", name: "symbol_", type: "string" },
        { internalType: "address", name: "newOwner_", type: "address" },
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        params: {
          name_: "The name of the token",
          newOwner_: "The owner of the the token-Metadata",
          symbol_: "The symbol of the token",
        },
      },
      userdoc: {
        notice: "Sets the token-Metadata and register LSP8InterfaceId",
      },
    },

    /**
     * function isOperatorFor(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x2a3654a4 = keccak256('isOperatorFor(address,bytes32)')
     */
    "0x2a3654a4": {
      sig: "isOperatorFor(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "isOperatorFor",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns whether `operator` address is an operator of `tokenId`. Operators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator. Requirements - `tokenId` must exist.",
        params: {
          operator: "The address to query",
          tokenId: "The tokenId to query",
        },
        returns: {
          _0: "True if the owner of `tokenId` is `operator` address, false otherwise",
        },
      },
    },

    /**
     * function mint(
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0xaf255b61 = keccak256('mint(address,bytes32,bool,bytes)')
     */
    "0xaf255b61": {
      sig: "mint(address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Mints `amount` tokens and transfers it to `to`. Requirements: - `to` cannot be the zero address. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          to: "The address to mint tokens",
          tokenId: "The tokenId to mint",
        },
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      },
    },

    /**
     * function revokeOperator(
     *  address operator,
     *  bytes32 tokenId
     * )
     *
     * 0x0b0c6d82 = keccak256('revokeOperator(address,bytes32)')
     */
    "0x0b0c6d82": {
      sig: "revokeOperator(address,bytes32)",
      inputs: [
        { internalType: "address", name: "operator", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
      ],
      name: "revokeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Removes `operator` address as an operator of `tokenId`. See {isOperatorFor}. Requirements - `tokenId` must exist. - caller must be current `tokenOwner` of `tokenId`. - `operator` cannot be the zero address. Emits a {RevokedOperator} event.",
        params: {
          operator: "The address to revoke as an operator.",
          tokenId: "The tokenId `operator` is revoked from operating",
        },
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data for multiple given `dataKeys` SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function tokenIdsOf(
     *  address tokenOwner
     * )
     *
     * 0xa3b261f2 = keccak256('tokenIdsOf(address)')
     */
    "0xa3b261f2": {
      sig: "tokenIdsOf(address)",
      inputs: [
        { internalType: "address", name: "tokenOwner", type: "address" },
      ],
      name: "tokenIdsOf",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the list of `tokenIds` for the `tokenOwner` address.",
        params: { tokenOwner: "The address to query owned tokens" },
        returns: { _0: "List of owned tokens by `tokenOwner` address" },
      },
    },

    /**
     * function tokenOwnerOf(
     *  bytes32 tokenId
     * )
     *
     * 0x217b2270 = keccak256('tokenOwnerOf(bytes32)')
     */
    "0x217b2270": {
      sig: "tokenOwnerOf(bytes32)",
      inputs: [{ internalType: "bytes32", name: "tokenId", type: "bytes32" }],
      name: "tokenOwnerOf",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns the `tokenOwner` address of the `tokenId` token. Requirements: - `tokenId` must exist.",
        params: { tokenId: "The tokenId to query" },
        returns: { _0: "The address owning the `tokenId`" },
      },
    },

    /**
     * function totalSupply()
     *
     * 0x18160ddd = keccak256('totalSupply()')
     */
    "0x18160ddd": {
      sig: "totalSupply()",
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details: "Returns the number of existing tokens.",
        returns: { _0: "The number of existing tokens" },
      },
    },

    /**
     * function transfer(
     *  address from,
     *  address to,
     *  bytes32 tokenId,
     *  bool allowNonLSP1Recipient,
     *  bytes data
     * )
     *
     * 0x511b6952 = keccak256('transfer(address,address,bytes32,bool,bytes)')
     */
    "0x511b6952": {
      sig: "transfer(address,address,bytes32,bool,bytes)",
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "bytes32", name: "tokenId", type: "bytes32" },
        { internalType: "bool", name: "allowNonLSP1Recipient", type: "bool" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "transfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of `tokenId`. Emits a {Transfer} event.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The sending address.",
          to: "The receiving address.",
          tokenId: "The tokenId to transfer.",
        },
      },
    },

    /**
     * function transferBatch(
     *  address[] from,
     *  address[] to,
     *  bytes32[] tokenId,
     *  bool[] allowNonLSP1Recipient,
     *  bytes[] data
     * )
     *
     * 0x7e87632c = keccak256('transferBatch(address[],address[],bytes32[],bool[],bytes[])')
     */
    "0x7e87632c": {
      sig: "transferBatch(address[],address[],bytes32[],bool[],bytes[])",
      inputs: [
        { internalType: "address[]", name: "from", type: "address[]" },
        { internalType: "address[]", name: "to", type: "address[]" },
        { internalType: "bytes32[]", name: "tokenId", type: "bytes32[]" },
        {
          internalType: "bool[]",
          name: "allowNonLSP1Recipient",
          type: "bool[]",
        },
        { internalType: "bytes[]", name: "data", type: "bytes[]" },
      ],
      name: "transferBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers many tokens based on the list `from`, `to`, `tokenId`. If any transfer fails the call will revert. Requirements: - `from`, `to`, `tokenId` lists are the same length. - no values in `from` can be the zero address. - no values in `to` can be the zero address. - `from` and `to` cannot be the same address at the same index of each lists. - each `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`. Emits {Transfer} events.",
        params: {
          allowNonLSP1Recipient:
            "When set to TRUE, to may be any address but when set to FALSE to must be a contract that supports LSP1 UniversalReceiver",
          data: "Additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.",
          from: "The list of sending addresses.",
          to: "The list of receiving addresses.",
          tokenId: "The list of tokenId to transfer.",
        },
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      },
    },
  },
  LSP9Vault: {
    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()
     *
     * 0xead3fbdf = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()')
     */
    "0xead3fbdf": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()
     *
     * 0x01bfba61 = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()')
     */
    "0x01bfba61": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function acceptOwnership()
     *
     * 0x79ba5097 = keccak256('acceptOwnership()')
     */
    "0x79ba5097": {
      sig: "acceptOwnership()",
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "same as ILSP14.acceptOwnership with the additional requirement: Requirements: - when notifying the previous owner via LSP1, the typeId used MUST be keccak256('LSP9OwnershipTransferred_SenderNotification') - when notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP9OwnershipTransferred_RecipientNotification')",
      },
    },

    /**
     * function batchCalls(
     *  bytes[] data
     * )
     *
     * 0x6963d438 = keccak256('batchCalls(bytes[])')
     */
    "0x6963d438": {
      sig: "batchCalls(bytes[])",
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "batchCalls",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Receives and executes a batch of function calls on this contract.",
      },
    },

    /**
     * function execute(
     *  uint256 operationType,
     *  address target,
     *  uint256 value,
     *  bytes data
     * )
     *
     * 0x44c028fe = keccak256('execute(uint256,address,uint256,bytes)')
     */
    "0x44c028fe": {
      sig: "execute(uint256,address,uint256,bytes)",
      inputs: [
        { internalType: "uint256", name: "operationType", type: "uint256" },
        { internalType: "address", name: "target", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "execute",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Executes any other smart contract. SHOULD only be callable by the owner of the contract set via ERC173 Emits a {Executed} event, when a call is executed under `operationType` 0 and 3 Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 Emits a {ValueReceived} event, when receives native token",
        params: {
          operationType:
            "The operation to execute: CALL = 0 CREATE = 1 CREATE2 = 2 STATICCALL = 3",
        },
      },
    },

    /**
     * function executeBatch(
     *  uint256[] operationsType,
     *  address[] targets,
     *  uint256[] values,
     *  bytes[] datas
     * )
     *
     * 0x31858452 = keccak256('executeBatch(uint256[],address[],uint256[],bytes[])')
     */
    "0x31858452": {
      sig: "executeBatch(uint256[],address[],uint256[],bytes[])",
      inputs: [
        {
          internalType: "uint256[]",
          name: "operationsType",
          type: "uint256[]",
        },
        { internalType: "address[]", name: "targets", type: "address[]" },
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "datas", type: "bytes[]" },
      ],
      name: "executeBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Emits a {ValueReceived} event when receiving native tokens.",
        params: {
          datas:
            "The list of call data, or the creation bytecode of the contract to deploy",
          operationsType:
            "The list of operations type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",
          targets:
            "The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",
          values: "The list of native token amounts to transfer (in Wei)",
        },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function pendingOwner()
     *
     * 0xe30c3978 = keccak256('pendingOwner()')
     */
    "0xe30c3978": {
      sig: "pendingOwner()",
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "The address that ownership of the contract is transferred to. This address may use `acceptOwnership()` to gain ownership of the contract.",
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Renounce ownership of the contract in a 2-step process. 1. the first call will initiate the process of renouncing ownership. 2. the second is used as a confirmation and will leave the contract without an owner. WARNING: once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.",
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets data as bytes in the vault storage for a single key. SHOULD only be callable by the owner of the contract set via ERC173 and the UniversalReceiverDelegate Emits a {DataChanged} event.",
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data at multiple given `key` SHOULD only be callable by the owner of the contract set via ERC173 and the UniversalReceiverDelegate Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns true if this contract implements the interface defined by `interfaceId`. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to LSP17, and checks if the extension implements the interface defined by `interfaceId`.",
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "same as ILSP14.transferOwnership with the additional requirement: Requirements:  - when notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP9OwnershipTransferStarted')",
        params: {
          newOwner:
            "the address of the new owner. Requirements: - `newOwner` MUST NOT accept ownership of the contract in the same transaction.",
        },
      },
    },

    /**
     * function universalReceiver(
     *  bytes32 typeId,
     *  bytes receivedData
     * )
     *
     * 0x6bb56a14 = keccak256('universalReceiver(bytes32,bytes)')
     */
    "0x6bb56a14": {
      sig: "universalReceiver(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "typeId", type: "bytes32" },
        { internalType: "bytes", name: "receivedData", type: "bytes" },
      ],
      name: "universalReceiver",
      outputs: [
        { internalType: "bytes", name: "returnedValues", type: "bytes" },
      ],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          receivedData: "The data received.",
          typeId: "The type of call received.",
        },
        returns: {
          returnedValues:
            "The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call.",
        },
      },
      userdoc: {
        notice:
          "Triggers the UniversalReceiver event when this function gets executed successfully. Forwards the call to the addresses stored in the ERC725Y storage under the LSP1UniversalReceiverDelegate Key and the typeId Key (param) respectively. The call will be discarded if no addresses are set.",
      },
    },
  },
  LSP9VaultInit: {
    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()
     *
     * 0xead3fbdf = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()')
     */
    "0xead3fbdf": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()
     *
     * 0x01bfba61 = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()')
     */
    "0x01bfba61": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function acceptOwnership()
     *
     * 0x79ba5097 = keccak256('acceptOwnership()')
     */
    "0x79ba5097": {
      sig: "acceptOwnership()",
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "same as ILSP14.acceptOwnership with the additional requirement: Requirements: - when notifying the previous owner via LSP1, the typeId used MUST be keccak256('LSP9OwnershipTransferred_SenderNotification') - when notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP9OwnershipTransferred_RecipientNotification')",
      },
    },

    /**
     * function batchCalls(
     *  bytes[] data
     * )
     *
     * 0x6963d438 = keccak256('batchCalls(bytes[])')
     */
    "0x6963d438": {
      sig: "batchCalls(bytes[])",
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "batchCalls",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Receives and executes a batch of function calls on this contract.",
      },
    },

    /**
     * function execute(
     *  uint256 operationType,
     *  address target,
     *  uint256 value,
     *  bytes data
     * )
     *
     * 0x44c028fe = keccak256('execute(uint256,address,uint256,bytes)')
     */
    "0x44c028fe": {
      sig: "execute(uint256,address,uint256,bytes)",
      inputs: [
        { internalType: "uint256", name: "operationType", type: "uint256" },
        { internalType: "address", name: "target", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "execute",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Executes any other smart contract. SHOULD only be callable by the owner of the contract set via ERC173 Emits a {Executed} event, when a call is executed under `operationType` 0 and 3 Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 Emits a {ValueReceived} event, when receives native token",
        params: {
          operationType:
            "The operation to execute: CALL = 0 CREATE = 1 CREATE2 = 2 STATICCALL = 3",
        },
      },
    },

    /**
     * function executeBatch(
     *  uint256[] operationsType,
     *  address[] targets,
     *  uint256[] values,
     *  bytes[] datas
     * )
     *
     * 0x31858452 = keccak256('executeBatch(uint256[],address[],uint256[],bytes[])')
     */
    "0x31858452": {
      sig: "executeBatch(uint256[],address[],uint256[],bytes[])",
      inputs: [
        {
          internalType: "uint256[]",
          name: "operationsType",
          type: "uint256[]",
        },
        { internalType: "address[]", name: "targets", type: "address[]" },
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "datas", type: "bytes[]" },
      ],
      name: "executeBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Emits a {ValueReceived} event when receiving native tokens.",
        params: {
          datas:
            "The list of call data, or the creation bytecode of the contract to deploy",
          operationsType:
            "The list of operations type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",
          targets:
            "The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",
          values: "The list of native token amounts to transfer (in Wei)",
        },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function initialize(
     *  address newOwner
     * )
     *
     * 0xc4d66de8 = keccak256('initialize(address)')
     */
    "0xc4d66de8": {
      sig: "initialize(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "initialize",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets the owner of the contract and sets the SupportedStandards:LSP9Vault key",
        params: { newOwner: "the owner of the contract" },
      },
      userdoc: { notice: "Initializing the contract owner to: `newOwner`" },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function pendingOwner()
     *
     * 0xe30c3978 = keccak256('pendingOwner()')
     */
    "0xe30c3978": {
      sig: "pendingOwner()",
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "The address that ownership of the contract is transferred to. This address may use `acceptOwnership()` to gain ownership of the contract.",
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Renounce ownership of the contract in a 2-step process. 1. the first call will initiate the process of renouncing ownership. 2. the second is used as a confirmation and will leave the contract without an owner. WARNING: once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.",
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets data as bytes in the vault storage for a single key. SHOULD only be callable by the owner of the contract set via ERC173 and the UniversalReceiverDelegate Emits a {DataChanged} event.",
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set SHOULD only be callable by the owner of the contract set via ERC173 The function is marked as payable to enable flexibility on child contracts If the function is not intended to receive value, an additional check should be implemented to check that value equal 0. Emits a {DataChanged} event.",
        },
      },
      userdoc: { notice: "Sets singular data for a given `dataKey`" },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Sets array of data at multiple given `key` SHOULD only be callable by the owner of the contract set via ERC173 and the UniversalReceiverDelegate Emits a {DataChanged} event.",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues: "The array of values to set",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns true if this contract implements the interface defined by `interfaceId`. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to LSP17, and checks if the extension implements the interface defined by `interfaceId`.",
      },
    },

    /**
     * function transferOwnership(
     *  address newOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "same as ILSP14.transferOwnership with the additional requirement: Requirements:  - when notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP9OwnershipTransferStarted')",
        params: {
          newOwner:
            "the address of the new owner. Requirements: - `newOwner` MUST NOT accept ownership of the contract in the same transaction.",
        },
      },
    },

    /**
     * function universalReceiver(
     *  bytes32 typeId,
     *  bytes receivedData
     * )
     *
     * 0x6bb56a14 = keccak256('universalReceiver(bytes32,bytes)')
     */
    "0x6bb56a14": {
      sig: "universalReceiver(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "typeId", type: "bytes32" },
        { internalType: "bytes", name: "receivedData", type: "bytes" },
      ],
      name: "universalReceiver",
      outputs: [
        { internalType: "bytes", name: "returnedValues", type: "bytes" },
      ],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        params: {
          receivedData: "The data received.",
          typeId: "The type of call received.",
        },
        returns: {
          returnedValues:
            "The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call.",
        },
      },
      userdoc: {
        notice:
          "Triggers the UniversalReceiver event when this function gets executed successfully. Forwards the call to the addresses stored in the ERC725Y storage under the LSP1UniversalReceiverDelegate Key and the typeId Key (param) respectively. The call will be discarded if no addresses are set.",
      },
    },
  },
  UniversalReceiverAddressStore: {
    /**
     * function account()
     *
     * 0x5dab2420 = keccak256('account()')
     */
    "0x5dab2420": {
      sig: "account()",
      inputs: [],
      name: "account",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function addAddress(
     *  address _address
     * )
     *
     * 0x38eada1c = keccak256('addAddress(address)')
     */
    "0x38eada1c": {
      sig: "addAddress(address)",
      inputs: [{ internalType: "address", name: "_address", type: "address" }],
      name: "addAddress",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function containsAddress(
     *  address _address
     * )
     *
     * 0x322433e3 = keccak256('containsAddress(address)')
     */
    "0x322433e3": {
      sig: "containsAddress(address)",
      inputs: [{ internalType: "address", name: "_address", type: "address" }],
      name: "containsAddress",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function getAddress(
     *  uint256 _index
     * )
     *
     * 0xb93f9b0a = keccak256('getAddress(uint256)')
     */
    "0xb93f9b0a": {
      sig: "getAddress(uint256)",
      inputs: [{ internalType: "uint256", name: "_index", type: "uint256" }],
      name: "getAddress",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function getAllRawValues()
     *
     * 0xc0a4ebf4 = keccak256('getAllRawValues()')
     */
    "0xc0a4ebf4": {
      sig: "getAllRawValues()",
      inputs: [],
      name: "getAllRawValues",
      outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function getIndex(
     *  address _address
     * )
     *
     * 0xb31610db = keccak256('getIndex(address)')
     */
    "0xb31610db": {
      sig: "getIndex(address)",
      inputs: [{ internalType: "address", name: "_address", type: "address" }],
      name: "getIndex",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function length()
     *
     * 0x1f7b6d32 = keccak256('length()')
     */
    "0x1f7b6d32": {
      sig: "length()",
      inputs: [],
      name: "length",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function removeAddress(
     *  address _address
     * )
     *
     * 0x4ba79dfe = keccak256('removeAddress(address)')
     */
    "0x4ba79dfe": {
      sig: "removeAddress(address)",
      inputs: [{ internalType: "address", name: "_address", type: "address" }],
      name: "removeAddress",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "See {IERC165-supportsInterface}." },
    },

    /**
     * function universalReceiverDelegate(
     *  address sender,
     *  uint256 ,
     *  bytes32 typeId,
     *  bytes
     * )
     *
     * 0xa245bbda = keccak256('universalReceiverDelegate(address,uint256,bytes32,bytes)')
     */
    "0xa245bbda": {
      sig: "universalReceiverDelegate(address,uint256,bytes32,bytes)",
      inputs: [
        { internalType: "address", name: "sender", type: "address" },
        { internalType: "uint256", name: "", type: "uint256" },
        { internalType: "bytes32", name: "typeId", type: "bytes32" },
        { internalType: "bytes", name: "", type: "bytes" },
      ],
      name: "universalReceiverDelegate",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  },
  UniversalProfile: {
    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()
     *
     * 0xead3fbdf = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()')
     */
    "0xead3fbdf": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()
     *
     * 0x01bfba61 = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()')
     */
    "0x01bfba61": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function acceptOwnership()
     *
     * 0x79ba5097 = keccak256('acceptOwnership()')
     */
    "0x79ba5097": {
      sig: "acceptOwnership()",
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfer ownership of the contract from the current `owner()` to the `pendingOwner()`. Once this function is called: - the current `owner()` will loose access to the functions restricted to the `owner()` only. - the `pendingOwner()` will gain access to the functions restricted to the `owner()` only. Requirements: - MUST be called by the pendingOwner. - When notifying the previous owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferred_SenderNotification'). - When notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferred_RecipientNotification').",
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.",
      },
    },

    /**
     * function batchCalls(
     *  bytes[] data
     * )
     *
     * 0x6963d438 = keccak256('batchCalls(bytes[])')
     */
    "0x6963d438": {
      sig: "batchCalls(bytes[])",
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "batchCalls",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Allows a caller to batch different function calls in one call. Perform a delegatecall on self, to call different functions with preserving the context It is not possible to send value along the functions call due to the use of delegatecall.",
        params: {
          data: "An array of ABI encoded function calls to be called on the contract.",
        },
        returns: {
          results: "An array of values returned by the executed functions.",
        },
      },
    },

    /**
     * function execute(
     *  uint256 operationType,
     *  address target,
     *  uint256 value,
     *  bytes data
     * )
     *
     * 0x44c028fe = keccak256('execute(uint256,address,uint256,bytes)')
     */
    "0x44c028fe": {
      sig: "execute(uint256,address,uint256,bytes)",
      inputs: [
        { internalType: "uint256", name: "operationType", type: "uint256" },
        { internalType: "address", name: "target", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "execute",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Executes any call on other addresses.",
        params: {
          data: "The call data to execute on `target`, or the bytecode of the contract to deploy Requirements: - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully. - if the operation type is {STATICCALL} or {DELEGATECALL}, `value` SHOULD be 0. - `target` SHOULD be address(0) when deploying a contract. - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4 Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 Emits a {ValueReceived} event when receiving native tokens.",
          operationType:
            "The operation to execute: CALL = 0 CREATE = 1 CREATE2 = 2 STATICCALL = 3 DELEGATECALL = 4",
          target:
            "The address (smart contract/EOA) to interact with, `target` will be unused if a contract is created (operation 1 and 2)",
          value: "The amount of native tokens to transfer (in Wei).",
        },
      },
    },

    /**
     * function executeBatch(
     *  uint256[] operationsType,
     *  address[] targets,
     *  uint256[] values,
     *  bytes[] datas
     * )
     *
     * 0x31858452 = keccak256('executeBatch(uint256[],address[],uint256[],bytes[])')
     */
    "0x31858452": {
      sig: "executeBatch(uint256[],address[],uint256[],bytes[])",
      inputs: [
        {
          internalType: "uint256[]",
          name: "operationsType",
          type: "uint256[]",
        },
        { internalType: "address[]", name: "targets", type: "address[]" },
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "datas", type: "bytes[]" },
      ],
      name: "executeBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Generic batch executor function that executes any call on other addresses",
        params: {
          datas:
            "The list of call data to execute on `targets`, or the creation bytecode of the contracts to deploy Requirements: - The length of the parameters provided MUST be equal - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully. - if the operation type is {STATICCALL} or {DELEGATECALL}, `value` SHOULD be 0. - `target` SHOULD be address(0) when deploying a contract. - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4 (each iteration) Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 (each iteration) Emits a {ValueReceived} event when receiving native tokens.",
          operationsType:
            "The list of operations type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",
          targets:
            "The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",
          values: "The list of native token amounts to transfer (in Wei)",
        },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function isValidSignature(
     *  bytes32 dataHash,
     *  bytes signature
     * )
     *
     * 0x1626ba7e = keccak256('isValidSignature(bytes32,bytes)')
     */
    "0x1626ba7e": {
      sig: "isValidSignature(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataHash", type: "bytes32" },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "isValidSignature",
      outputs: [{ internalType: "bytes4", name: "magicValue", type: "bytes4" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Handles two cases: - If the owner is an EOA, recovers an address from the hash and the signature provided:      - Returns the magicValue if the address recovered is the same as the owner, indicating        that it was a valid signature.      - If the address is different, it returns the fail value indicating that the signature is not valid. - If the owner is a smart contract, it forwards the call of {isValidSignature} to the owner contract:      - If the contract fails or returns the fail value, the {isValidSignature} on the account returns the        fail value, indicating that the signature is not valid.      - If the {isValidSignature} on the owner returned the magicValue, the {isValidSignature} on the account        returns the magicValue, indicating that it's a valid signature.",
        params: {
          dataHash: "The hash of the data to be validated.",
          signature:
            "A signature that can validate the previous parameter (Hash).",
        },
        returns: {
          magicValue:
            "A bytes4 value that indicates if the signature is valid or not.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of EIP-1271 by validating signatures of smart contracts according to their own logic.",
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function pendingOwner()
     *
     * 0xe30c3978 = keccak256('pendingOwner()')
     */
    "0xe30c3978": {
      sig: "pendingOwner()",
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "The address that ownership of the contract is transferred to. This address may use `acceptOwnership()` to gain ownership of the contract.",
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Renounce ownership of the contract in a 2-step process. 1. the first call will initiate the process of renouncing ownership. 2. the second is used as a confirmation and will leave the contract without an owner. MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification WARNING: once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.",
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership renouncing process.",
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Sets singular data for a given `dataKey`",
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set Requirements: - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {ValueReceived} event when receiving native tokens. Emits a {DataChanged} event.",
        },
      },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Sets array of data for multiple given `dataKeys`",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues:
            "The array of values to set Requirements: - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {ValueReceived} event when receiving native tokens. Emits a {DataChanged} event. (on each iteration of setting data)",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns true if this contract implements the interface defined by `interfaceId`. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to LSP17, and checks if the extension implements the interface defined by `interfaceId`.",
      },
      userdoc: {
        notice:
          "Achieves the goal of ERC165 to detect supported interfaces and LSP17 by checking if the interfaceId being queried is supported on another linked extension.",
      },
    },

    /**
     * function transferOwnership(
     *  address _pendingOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [
        { internalType: "address", name: "_pendingOwner", type: "address" },
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Sets the pending owner address as an address that should call {acceptOwnership} in order to complete the ownership transfer of the account. Notifies the pending owner via LSP1Standard by calling {universalReceiver} on the pending owner if it's an address that supports LSP1.",
        params: {
          _pendingOwner:
            "The address of the new pending owner. Requirements: - MUST pass when called by the owner or by an authorized address that passes the verification check performed   on the owner according to LSP20 - CallVerification specification. - When notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferStarted'). - pending owner cannot accept ownership in the same tx via the LSP1 hook.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.",
      },
    },

    /**
     * function universalReceiver(
     *  bytes32 typeId,
     *  bytes receivedData
     * )
     *
     * 0x6bb56a14 = keccak256('universalReceiver(bytes32,bytes)')
     */
    "0x6bb56a14": {
      sig: "universalReceiver(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "typeId", type: "bytes32" },
        { internalType: "bytes", name: "receivedData", type: "bytes" },
      ],
      name: "universalReceiver",
      outputs: [
        { internalType: "bytes", name: "returnedValues", type: "bytes" },
      ],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "The function performs the following steps: - Emits {ValueReceived} when receiving native tokens. - Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY}.      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting        of 20 bytes of {msg.sender} and 32 bytes of {msg.value}. If not, continue the execution of the function. - Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY + <bytes32 typeId>}.   (Check {LSP2-ERC725YJSONSchema} for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting        of 20 bytes of {msg.sender} and 32 bytes of {msg.value}. If not, continue the execution of the function. - Emits a {UniversalReceiver} event.",
        params: {
          receivedData: "The data received.",
          typeId: "The type of call received.",
        },
        returns: {
          returnedValues:
            "The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP1-UniversalReceiver by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts (UniversalReceiverDelegates) that react on the whole transaction and on the specific typeId, respectively. The notification is achieved by emitting a {UniversalReceiver} event on the call with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract.",
      },
    },
  },
  UniversalProfileInit: {
    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()
     *
     * 0xead3fbdf = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()')
     */
    "0xead3fbdf": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()
     *
     * 0x01bfba61 = keccak256('RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()')
     */
    "0x01bfba61": {
      sig: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD()",
      inputs: [],
      name: "RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },

    /**
     * function acceptOwnership()
     *
     * 0x79ba5097 = keccak256('acceptOwnership()')
     */
    "0x79ba5097": {
      sig: "acceptOwnership()",
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Transfer ownership of the contract from the current `owner()` to the `pendingOwner()`. Once this function is called: - the current `owner()` will loose access to the functions restricted to the `owner()` only. - the `pendingOwner()` will gain access to the functions restricted to the `owner()` only. Requirements: - MUST be called by the pendingOwner. - When notifying the previous owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferred_SenderNotification'). - When notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferred_RecipientNotification').",
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.",
      },
    },

    /**
     * function batchCalls(
     *  bytes[] data
     * )
     *
     * 0x6963d438 = keccak256('batchCalls(bytes[])')
     */
    "0x6963d438": {
      sig: "batchCalls(bytes[])",
      inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
      name: "batchCalls",
      outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Allows a caller to batch different function calls in one call. Perform a delegatecall on self, to call different functions with preserving the context It is not possible to send value along the functions call due to the use of delegatecall.",
        params: {
          data: "An array of ABI encoded function calls to be called on the contract.",
        },
        returns: {
          results: "An array of values returned by the executed functions.",
        },
      },
    },

    /**
     * function execute(
     *  uint256 operationType,
     *  address target,
     *  uint256 value,
     *  bytes data
     * )
     *
     * 0x44c028fe = keccak256('execute(uint256,address,uint256,bytes)')
     */
    "0x44c028fe": {
      sig: "execute(uint256,address,uint256,bytes)",
      inputs: [
        { internalType: "uint256", name: "operationType", type: "uint256" },
        { internalType: "address", name: "target", type: "address" },
        { internalType: "uint256", name: "value", type: "uint256" },
        { internalType: "bytes", name: "data", type: "bytes" },
      ],
      name: "execute",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Executes any call on other addresses.",
        params: {
          data: "The call data to execute on `target`, or the bytecode of the contract to deploy Requirements: - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully. - if the operation type is {STATICCALL} or {DELEGATECALL}, `value` SHOULD be 0. - `target` SHOULD be address(0) when deploying a contract. - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4 Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 Emits a {ValueReceived} event when receiving native tokens.",
          operationType:
            "The operation to execute: CALL = 0 CREATE = 1 CREATE2 = 2 STATICCALL = 3 DELEGATECALL = 4",
          target:
            "The address (smart contract/EOA) to interact with, `target` will be unused if a contract is created (operation 1 and 2)",
          value: "The amount of native tokens to transfer (in Wei).",
        },
      },
    },

    /**
     * function executeBatch(
     *  uint256[] operationsType,
     *  address[] targets,
     *  uint256[] values,
     *  bytes[] datas
     * )
     *
     * 0x31858452 = keccak256('executeBatch(uint256[],address[],uint256[],bytes[])')
     */
    "0x31858452": {
      sig: "executeBatch(uint256[],address[],uint256[],bytes[])",
      inputs: [
        {
          internalType: "uint256[]",
          name: "operationsType",
          type: "uint256[]",
        },
        { internalType: "address[]", name: "targets", type: "address[]" },
        { internalType: "uint256[]", name: "values", type: "uint256[]" },
        { internalType: "bytes[]", name: "datas", type: "bytes[]" },
      ],
      name: "executeBatch",
      outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "Generic batch executor function that executes any call on other addresses",
        params: {
          datas:
            "The list of call data to execute on `targets`, or the creation bytecode of the contracts to deploy Requirements: - The length of the parameters provided MUST be equal - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully. - if the operation type is {STATICCALL} or {DELEGATECALL}, `value` SHOULD be 0. - `target` SHOULD be address(0) when deploying a contract. - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4 (each iteration) Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2 (each iteration) Emits a {ValueReceived} event when receiving native tokens.",
          operationsType:
            "The list of operations type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4",
          targets:
            "The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).",
          values: "The list of native token amounts to transfer (in Wei)",
        },
      },
    },

    /**
     * function getData(
     *  bytes32 dataKey
     * )
     *
     * 0x54f6127f = keccak256('getData(bytes32)')
     */
    "0x54f6127f": {
      sig: "getData(bytes32)",
      inputs: [{ internalType: "bytes32", name: "dataKey", type: "bytes32" }],
      name: "getData",
      outputs: [{ internalType: "bytes", name: "dataValue", type: "bytes" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKey: "The key which value to retrieve" },
        returns: { dataValue: "The data stored at the key" },
      },
      userdoc: { notice: "Gets singular data at a given `dataKey`" },
    },

    /**
     * function getDataBatch(
     *  bytes32[] dataKeys
     * )
     *
     * 0xdedff9c6 = keccak256('getDataBatch(bytes32[])')
     */
    "0xdedff9c6": {
      sig: "getDataBatch(bytes32[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
      ],
      name: "getDataBatch",
      outputs: [
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      stateMutability: "view",
      type: "function",
      devdoc: {
        params: { dataKeys: "The array of keys which values to retrieve" },
        returns: { dataValues: "The array of data stored at multiple keys" },
      },
      userdoc: { notice: "Gets array of data for multiple given keys" },
    },

    /**
     * function initialize(
     *  address newOwner
     * )
     *
     * 0xc4d66de8 = keccak256('initialize(address)')
     */
    "0xc4d66de8": {
      sig: "initialize(address)",
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "initialize",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: { params: { newOwner: "the owner of the contract" } },
      userdoc: {
        notice:
          "Sets the owner of the contract and sets the SupportedStandards:LSP3UniversalProfile key",
      },
    },

    /**
     * function isValidSignature(
     *  bytes32 dataHash,
     *  bytes signature
     * )
     *
     * 0x1626ba7e = keccak256('isValidSignature(bytes32,bytes)')
     */
    "0x1626ba7e": {
      sig: "isValidSignature(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataHash", type: "bytes32" },
        { internalType: "bytes", name: "signature", type: "bytes" },
      ],
      name: "isValidSignature",
      outputs: [{ internalType: "bytes4", name: "magicValue", type: "bytes4" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Handles two cases: - If the owner is an EOA, recovers an address from the hash and the signature provided:      - Returns the magicValue if the address recovered is the same as the owner, indicating        that it was a valid signature.      - If the address is different, it returns the fail value indicating that the signature is not valid. - If the owner is a smart contract, it forwards the call of {isValidSignature} to the owner contract:      - If the contract fails or returns the fail value, the {isValidSignature} on the account returns the        fail value, indicating that the signature is not valid.      - If the {isValidSignature} on the owner returned the magicValue, the {isValidSignature} on the account        returns the magicValue, indicating that it's a valid signature.",
        params: {
          dataHash: "The hash of the data to be validated.",
          signature:
            "A signature that can validate the previous parameter (Hash).",
        },
        returns: {
          magicValue:
            "A bytes4 value that indicates if the signature is valid or not.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of EIP-1271 by validating signatures of smart contracts according to their own logic.",
      },
    },

    /**
     * function owner()
     *
     * 0x8da5cb5b = keccak256('owner()')
     */
    "0x8da5cb5b": {
      sig: "owner()",
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: { details: "Returns the address of the current owner." },
    },

    /**
     * function pendingOwner()
     *
     * 0xe30c3978 = keccak256('pendingOwner()')
     */
    "0xe30c3978": {
      sig: "pendingOwner()",
      inputs: [],
      name: "pendingOwner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "The address that ownership of the contract is transferred to. This address may use `acceptOwnership()` to gain ownership of the contract.",
      },
    },

    /**
     * function renounceOwnership()
     *
     * 0x715018a6 = keccak256('renounceOwnership()')
     */
    "0x715018a6": {
      sig: "renounceOwnership()",
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Renounce ownership of the contract in a 2-step process. 1. the first call will initiate the process of renouncing ownership. 2. the second is used as a confirmation and will leave the contract without an owner. MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification WARNING: once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.",
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership renouncing process.",
      },
    },

    /**
     * function setData(
     *  bytes32 dataKey,
     *  bytes dataValue
     * )
     *
     * 0x7f23690c = keccak256('setData(bytes32,bytes)')
     */
    "0x7f23690c": {
      sig: "setData(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "dataKey", type: "bytes32" },
        { internalType: "bytes", name: "dataValue", type: "bytes" },
      ],
      name: "setData",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Sets singular data for a given `dataKey`",
        params: {
          dataKey: "The key to retrieve stored value",
          dataValue:
            "The value to set Requirements: - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {ValueReceived} event when receiving native tokens. Emits a {DataChanged} event.",
        },
      },
    },

    /**
     * function setDataBatch(
     *  bytes32[] dataKeys,
     *  bytes[] dataValues
     * )
     *
     * 0x97902421 = keccak256('setDataBatch(bytes32[],bytes[])')
     */
    "0x97902421": {
      sig: "setDataBatch(bytes32[],bytes[])",
      inputs: [
        { internalType: "bytes32[]", name: "dataKeys", type: "bytes32[]" },
        { internalType: "bytes[]", name: "dataValues", type: "bytes[]" },
      ],
      name: "setDataBatch",
      outputs: [],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details: "Sets array of data for multiple given `dataKeys`",
        params: {
          dataKeys: "The array of data keys for values to set",
          dataValues:
            "The array of values to set Requirements: - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to LSP20 - CallVerification specification Emits a {ValueReceived} event when receiving native tokens. Emits a {DataChanged} event. (on each iteration of setting data)",
        },
      },
    },

    /**
     * function supportsInterface(
     *  bytes4 interfaceId
     * )
     *
     * 0x01ffc9a7 = keccak256('supportsInterface(bytes4)')
     */
    "0x01ffc9a7": {
      sig: "supportsInterface(bytes4)",
      inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
      devdoc: {
        details:
          "Returns true if this contract implements the interface defined by `interfaceId`. If the contract doesn't support the `interfaceId`, it forwards the call to the `supportsInterface` extension according to LSP17, and checks if the extension implements the interface defined by `interfaceId`.",
      },
      userdoc: {
        notice:
          "Achieves the goal of ERC165 to detect supported interfaces and LSP17 by checking if the interfaceId being queried is supported on another linked extension.",
      },
    },

    /**
     * function transferOwnership(
     *  address _pendingOwner
     * )
     *
     * 0xf2fde38b = keccak256('transferOwnership(address)')
     */
    "0xf2fde38b": {
      sig: "transferOwnership(address)",
      inputs: [
        { internalType: "address", name: "_pendingOwner", type: "address" },
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
      devdoc: {
        details:
          "Sets the pending owner address as an address that should call {acceptOwnership} in order to complete the ownership transfer of the account. Notifies the pending owner via LSP1Standard by calling {universalReceiver} on the pending owner if it's an address that supports LSP1.",
        params: {
          _pendingOwner:
            "The address of the new pending owner. Requirements: - MUST pass when called by the owner or by an authorized address that passes the verification check performed   on the owner according to LSP20 - CallVerification specification. - When notifying the new owner via LSP1, the typeId used MUST be keccak256('LSP0OwnershipTransferStarted'). - pending owner cannot accept ownership in the same tx via the LSP1 hook.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.",
      },
    },

    /**
     * function universalReceiver(
     *  bytes32 typeId,
     *  bytes receivedData
     * )
     *
     * 0x6bb56a14 = keccak256('universalReceiver(bytes32,bytes)')
     */
    "0x6bb56a14": {
      sig: "universalReceiver(bytes32,bytes)",
      inputs: [
        { internalType: "bytes32", name: "typeId", type: "bytes32" },
        { internalType: "bytes", name: "receivedData", type: "bytes" },
      ],
      name: "universalReceiver",
      outputs: [
        { internalType: "bytes", name: "returnedValues", type: "bytes" },
      ],
      stateMutability: "payable",
      type: "function",
      devdoc: {
        details:
          "The function performs the following steps: - Emits {ValueReceived} when receiving native tokens. - Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY}.      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting        of 20 bytes of {msg.sender} and 32 bytes of {msg.value}. If not, continue the execution of the function. - Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY + <bytes32 typeId>}.   (Check {LSP2-ERC725YJSONSchema} for encoding the data key)      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.      - If yes, call this address with the typeId and data (params), along with additional calldata consisting        of 20 bytes of {msg.sender} and 32 bytes of {msg.value}. If not, continue the execution of the function. - Emits a {UniversalReceiver} event.",
        params: {
          receivedData: "The data received.",
          typeId: "The type of call received.",
        },
        returns: {
          returnedValues:
            "The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call.",
        },
      },
      userdoc: {
        notice:
          "Achieves the goal of LSP1-UniversalReceiver by allowing the account to be notified about incoming/outgoing transactions and enabling reactions to these actions. The reaction is achieved by having two external contracts (UniversalReceiverDelegates) that react on the whole transaction and on the specific typeId, respectively. The notification is achieved by emitting a {UniversalReceiver} event on the call with the function parameters, call options, and the response of the UniversalReceiverDelegates (URD) contract.",
      },
    },
  },
};
export const ContractsDocs = {};
export const StateVariables = {
  LSP16UniversalFactory: {
    /**
     * stateVariable _EMPTY_BYTE()
     *
     * 0x3bc60789 = keccak256('_EMPTY_BYTE()')
     */
    "0x3bc60789": {
      sig: "_EMPTY_BYTE()",
      type: "stateVariable",
      devdoc: {
        details:
          "placeholder for the `initializeCallData` param when the `initializable` boolean is set to `false`.",
      },
    },
  },
  LSP8CompatibleERC721: {
    /**
     * stateVariable _operatorApprovals()
     *
     * 0x87172cf3 = keccak256('_operatorApprovals()')
     */
    "0x87172cf3": {
      sig: "_operatorApprovals()",
      type: "stateVariable",
      devdoc: { details: "for backward compatibility with ERC721" },
    },
  },
  LSP8CompatibleERC721InitAbstract: {
    /**
     * stateVariable _operatorApprovals()
     *
     * 0x87172cf3 = keccak256('_operatorApprovals()')
     */
    "0x87172cf3": {
      sig: "_operatorApprovals()",
      type: "stateVariable",
      devdoc: { details: "for backward compatibility with ERC721" },
    },
  },
};
